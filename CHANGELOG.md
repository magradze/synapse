# ცვლილებების ისტორია (Changelog)

## [5.5.1] - 2025-08-16

### 🐛 გამოსწორებული შეცდომები (Fixed)

- **fix(buttons):** 🛡️ სრულად გადაკეთდა და გაუმჯობესდა `button_input` მოდულის `debounce` ალგორითმი. ახალი, მდგრადი ლოგიკა აღმოფხვრის ღილაკების "ორმაგი დაჭერის" პრობლემას, რომელიც გამოწვეული იყო როგორც ფიზიკური, ისე ლოგიკური "წრიპინით".
  - შეფერხება ახლა რეაგირებს მდგომარეობის ნებისმიერ ცვლილებაზე (`ANYEDGE`).
  - ღილაკის დამმუშავებელი ტასკი ახლა იყენებს მცირე დაყოვნებას სიგნალის დასასტაბილურებლად და მხოლოდ ამის შემდეგ კითხულობს პინის საბოლოო მდგომარეობას, რაც უზრუნველყოფს ერთი ფიზიკური დაჭერის ერთ ლოგიკურ ივენთად გარდაქმნას.
- **refactor(ui):** 🧹 `ui_manager`-იდან ამოღებულ იქნა ლოგიკური `cooldown` მექანიზმი, რადგან `button_input`-ის ახალი, გაუმჯობესებული `debounce` ლოგიკა მას არასაჭიროს ხდის.

---

## [5.5.0] - 2025-08-15

🎉 **ვერსია 5.5.0: ინტერაქტიული UI და ფუნქციონალური დახვეწა!** 🎉

ეს ვერსია აცოცხლებს მომხმარებლის ინტერფეისს და ამატებს მოდულების პირდაპირი მართვის შესაძლებლობას. განხორციელდა მნიშვნელოვანი შესწორებები და გაუმჯობესებები, რათა UI გამხდარიყო სრულად ფუნქციონალური, ინტუიციური და ვიზუალურად გამართული.

### ✨ დამატებული ფუნქციონალი (Added)

- **feat(ui):** 👆 დაემატა **მოდულის მართვის ეკრანი**. `Modules` მენიუდან კონკრეტული მოდულის არჩევისას, ახლა იხსნება ახალი ეკრანი, სადაც ნაჩვენებია მოდულის სახელი, სტატუსი (`Running`/`Disabled`) და ხელმისაწვდომი მოქმედებები.
- **feat(ui):** ⚡️ `relay_actuator` მოდულისთვის დაემატა **ინტერაქტიული მართვის** შესაძლებლობა. მართვის ეკრანზე `OK` ღილაკზე დაჭერით ახლა შესაძლებელია რელეს მდგომარეობის შეცვლა (`Toggle`), რაც მომენტალურად აისახება ეკრანზე.

### 🔄 შეცვლილი და გაუმჯობესებული ფუნქციონალი (Changed)

- **improve(ui):** 💅🏻 `Modules` მენიუში მოდულების სახელები ახლა ავტომატურად ფორმატდება — სისტემური სახელები (`main_light`) გარდაიქმნება ადამიანისთვის გასაგებ ფორმატში (`Main Light`).
- **improve(ui):** 🧭 გაუმჯობესდა ნავიგაცია მოდულის მართვის ეკრანზე. `UP`/`DOWN` ღილაკები ახლა კორექტულად მუშაობს მოქმედებებსა და `BACK` ღილაკს შორის გადასასვლელად.
- **improve(ui):** 💾 მენიუდან მოდულის მართვის ეკრანზე გადასვლისას და უკან დაბრუნებისას, სისტემა ახლა **იმახსოვრებს და აღადგენს** ბოლოს არჩეული მოდულის პოზიციას სიაში, რაც აუმჯობესებს მომხმარებლის გამოცდილებას.

### 🐛 გამოსწორებული შეცდომები (Fixed)

- **fix(ui):** 🎨 გასწორდა ვიზუალური ხარვეზი, როდესაც მოდულის მართვის ეკრანზე ტექსტი ეფარებოდა ჰედერის არეს. ყველა ეკრანის კონტენტი ახლა კორექტულად თავსდება ხილვად არეში.
- **fix(relay):** ⚙️ სრულად გამოსწორდა `relay_actuator` მოდულის Service API-ს რეგისტრაციის ლოგიკა. ის ახლა კორექტულად არეგისტრირებს `FMW_SERVICE_TYPE_RELAY_API` ტიპის სერვისს, რაც `ui_manager`-ს საშუალებას აძლევს, სწორად ამოიცნოს და მართოს რელე.

---

## [5.4.0] - 2025-08-14

🎉 **ვერსია 5.4.0: არქიტექტურული რევოლუცია — მოდულური UI და ეკრანის აბსტრაქცია!** 🎉

ეს ვერსია წარმოადგენს Synapse Framework-ის მომხმარებლის ინტერფეისის სრულ ტრანსფორმაციას. დაინერგა ეკრანის დრაივერის აბსტრაქციის ფენა და შეიქმნა ახალი, სრულად მოდულური `ui_manager`, რომელიც გამიჯნავს UI-ს ლოგიკას აპარატურისგან. შედეგად, ფრეიმვორქი მზად არის ნებისმიერი ტიპის ეკრანის მხარდაჭერისთვის.

### ✨ დამატებული ფუნქციონალი (Added)

- **feat(ui):** 🚀 დაინერგა **ეკრანის დრაივერის აბსტრაქციის ფენა** (`display_driver_interface.h`), რომელიც ქმნის უნივერსალურ "კონტრაქტს" ყველა ეკრანის მოდულისთვის.
- **feat(drivers):** 📺 შეიქმნა ახალი, სუფთა **`ssd1306_driver`** მოდული, რომელიც ახდენს ახალი ინტერფეისის იმპლემენტაციას და პასუხისმგებელია მხოლოდ SSD1306 ეკრანთან პირდაპირ კომუნიკაციაზე.
- **feat(ui):** 🧠 შეიქმნა ახალი, მაღალი დონის **`ui_manager`** მოდული, რომელიც სრულად მართავს UI-ს ლოგიკას:
  - **მდგომარეობის მანქანა:** მართავს ეკრანებს შორის გადასვლას (Splash, Home, Menus).
  - **დინამიური მენიუ:** ავტომატურად აგებს მენიუს სისტემაში არსებული მოდულების სიის მიხედვით.
  - **ადაპტირებადი დიზაინი:** UI-ს ყველა ელემენტი (იკონები, ღილაკები, ტექსტი) დინამიურად თავსდება ეკრანზე მისი რეალური ზომების მიხედვით.
- **feat(ui):** 🎨 დაემატა პროპორციული, დიდი ზომის ფონტების მხარდაჭერა Splash Screen-ისა და საათის გამოსახვისთვის.
- **feat(system):** ⏳ დაემატა **`time_sync`** მოდულის მინიმალური, "ყალბი" ვერსია, `ui_manager`-ის დროზე დამოკიდებულების დასაკმაყოფილებლად.

### 🔄 შეცვლილი და გაუმჯობესებული ფუნქციონალი (Changed)

- **refactor(ui):** 🏗️ `ui_manager`-ის მონოლითური კოდი დაიშალა ლოგიკურ კომპონენტებად: `ui_events.c` (ივენთების დამუშავება), `ui_menu.c` (მენიუს ლოგიკა) და `ui_screens.c` (ეკრანების ხატვა), რამაც მნიშვნელოვნად გააუმჯობესა კოდის სტრუქტურა და წაკითხვადობა.
- **improve(ui):** 📶 გაუმჯობესდა WiFi სტატუსის განახლების ლოგიკა. `ui_manager` ახლა პერიოდულად ითხოვს სტატუსს და ანახლებს იკონკას მხოლოდ მაშინ, როდესაც რეალური ცვლილება ფიქსირდება.
- **improve(logger):** 🔇 `logger_module` ახლა ფილტრავს და აღარ ბეჭდავს მაღალი სიხშირის UI-ს განახლების ივენთებს, რაც სისტემის ლოგს ბევრად სუფთას ხდის.

### 🐛 გამოსწორებული შეცდომები (Fixed)

- **fix(ui):** 🐞 სრულად გამოსწორდა `linker`-ის შეცდომები (`undefined reference`, `redefinition`), რომლებიც გამოწვეული იყო რეფაქტორინგის დროს ფაილებს შორის არასწორი დამოკიდებულებებით.
- **fix(ui):** 🚫 გამოსწორდა ეკრანის ავტომატური გათიშვის ლოგიკა. ტაიმერი ახლა ნულდება მხოლოდ მომხმარებლის პირდაპირი ინტერაქციისას (ღილაკზე დაჭერა).
- **fix(ui):** ⬆️⬇️ გამოსწორდა მენიუში ნავიგაციისა და სქროლვის ლოგიკა, რაც უზრუნველყოფს ყველა ელემენტზე, მათ შორის "BACK" ღილაკზე, კორექტულ წვდომას.

## [5.3.0] - 2025-07-29

🎉 **ვერსია 5.3.0: ინტერაქტიული UI და "ჭკვიანი" ეკრანი!** 🎉

ეს ვერსია აცოცხლებს `ssd1306_oled_display` მოდულს და აქცევს მას სრულფასოვან, ინტერაქტიულ ინტერფეისად. დაემატა მრავალგვერდიანი მენიუს სისტემა, რომელიც დინამიურად ივსება სისტემაში არსებული მოდულებით და იმართება ფიზიკური ღილაკებით. ასევე, დაინერგა ეკრანის ავტომატური გათიშვის ფუნქცია ენერგიის დასაზოგად.

### ✨ Added (დამატებული ფუნქციონალი)

- **feat(ui):** 🧭 `ssd1306_oled_display` მოდულს დაემატა **მრავალგვერდიანი UI-ს ლოგიკა**.
  - **State Machine:** დაინერგა მდგომარეობის მანქანა (`UI_STATE_HOME`, `UI_STATE_MENU`, `UI_STATE_MODULE_CONTROL`), რომელიც მართავს, თუ რომელი "გვერდი" უნდა გამოჩნდეს ეკრანზე.
  - **დინამიური მენიუ:** მენიუს გვერდი ახლა `System Manager` სერვისის მეშვეობით დინამიურად იღებს სისტემაში არსებული ყველა მოდულის სიას და გამოაქვს ეკრანზე.
  - **Scrolling:** იმპლემენტირებულია მენიუს გრძელი სიის "დასქროლვის" ლოგიკა, რაც უზრუნველყოფს, რომ არჩეული პუნქტი ყოველთვის ხილვადია.
  - **მოდულის მართვის გვერდი:** მენიუდან მოდულის არჩევისას, UI გადადის მართვის გვერდზე, რაც ამზადებს საფუძველს მომავალი ინტერაქტიული კონტროლისთვის.

- **feat(ui):** ⚡ დაემატა **ეკრანის ენერგიის დაზოგვის** ფუნქციონალი.
  - **ავტომატური გათიშვა:** `System Timer`-ის მეშვეობით, ეკრანი ავტომატურად ითიშება მომხმარებლის უმოქმედობის (ღილაკზე არდაჭერის) განსაზღვრული პერიოდის შემდეგ.
  - **გაღვიძება ღილაკით:** ნებისმიერ ღილაკზე დაჭერა მომენტალურად "აღვიძებს" ეკრანს და ანახლებს ბოლო აქტივობის დროს.

### 🔄 Changed (შეცვლილი და გაუმჯობესებული ფუნქციონალი)

- **improve(ui):** 🛡️ `ssd1306_handle_event` ფუნქცია გახდა ბევრად უფრო მტკიცე და უსაფრთხო.
  - **Cooldown მექანიზმი:** დაემატა ღილაკების დაჭერის "გაგრილების პერიოდი" (cooldown), რაც სრულად აგვარებს ერთი დაჭერის მრავალჯერადი რეგისტრაციის პრობლემას.
  - **NULL Pointer დაცვა:** დაემატა მრავალი შემოწმება, რათა თავიდან ავიცილოთ სისტემის კრახი `NULL` მაჩვენებლებთან მუშაობისას.

### 🐛 Fixed (გამოსწორებული შეცდომები)

- **fix(ui):** 🐞 გასწორდა `LoadProhibited` პანიკა, რომელიც გამოწვეული იყო `handle_event` ფუნქციაში `menu_modules` მასივზე წვდომის მცდელობით მის ინიციალიზაციამდე.
- **fix(ui):** 📐 გასწორდა მენიუს რენდერინგის ლოგიკა, რათა სათაური და მენიუს პუნქტები კორექტულად გამოჩნდეს და არ გადაფაროს ერთმანეთი.

---

## [5.2.0] - 2025-07-28

🎉 **ვერსია 5.2.0: ვიზუალური რევოლუცია — სრულფასოვანი გრაფიკული UI!** 🎉

ეს ვერსია Synapse Framework-ს ამატებს მძლავრ ვიზუალურ შესაძლებლობებს `ssd1306_oled_display` მოდულის სრული ტრანსფორმაციით. მოდული ასინქრონული ტექსტის გამომტანიდან გადაიქცა სინქრონულ, ბუფერზე დაფუძნებულ გრაფიკულ ძრავად, რაც ხსნის გზას ინტერაქტიული მენიუებისა და დინამიური ინტერფეისების შესაქმნელად. პარალელურად, გასწორდა კრიტიკული არქიტექტურული შეცდომა `wifi_manager`-ში, რამაც მნიშვნელოვნად გაზარდა მთლიანი სისტემის სტაბილურობა.

### ✨ Added (დამატებული ფუნქციონალი)

- **feat(drivers):** 🔘 დაემატა ახალი, სრულფასოვანი **`button_input`** მოდული.
  - **შეფერხებებზე დაფუძნებული:** იყენებს GPIO ISR-ებს და FreeRTOS რიგს ღილაკების დაჭერის სწრაფი და არაბლოკირებადი დეტექციისთვის.
  - **Debouncing:** ჩაშენებული აქვს სიგნალის "გაწმენდის" მექანიზმი, რათა თავიდან ავიცილოთ ერთი დაჭერის მრავალჯერადი რეგისტრაცია.
  - **Event-driven:** დაჭერისას აქვეყნებს სტანდარტულ `FMW_EVENT_BUTTON_PRESSED` ივენთს, რაც უზრუნველყოფს სრულ იზოლაციას UI და სხვა მოდულებისგან.
  - **მოქნილი კონფიგურაცია:** `config.json`-ის საშუალებით შესაძლებელია ნებისმიერი რაოდენობის ღილაკის კონფიგურირება.

- **feat(displays):** 🖼️ `ssd1306_oled_display` მოდულს დაემატა **სრულფასოვანი გრაფიკული API**.
  - **შიდა ბუფერი:** მოდული ახლა მუშაობს შიდა `screen_buffer`-ზე, რაც უზრუნველყოფს ეკრანის "აციმციმების" გარეშე განახლებას.
  - **გრაფიკული პრიმიტივები:** Service API-ს დაემატა ახალი ფუნქციები: `draw_pixel`, `draw_hline`, `draw_vline`, `draw_rect`, `fill_rect`.
  - **სინქრონული განახლება:** დაემატა `update_screen()` API, რომელიც დეველოპერს აძლევს სრულ კონტროლს იმაზე, თუ როდის გადავიდეს ბუფერის შიგთავსი ფიზიკურ ეკრანზე.
  - **ტასკის რეფაქტორინგი:** ამოღებულ იქნა ასინქრონული `display_task` და `command_queue`, რამაც გაამარტივა ლოგიკა და შეამცირა რესურსების მოხმარება.

- **feat(testing):** 🧪 `selftest_manager`-ს დაემატა ახალი, **ვიზუალური ტესტი (`display`)**.
  - ეს ტესტი იყენებს `ssd1306` მოდულის ახალ გრაფიკულ API-ს, რათა ეკრანზე დახატოს სხვადასხვა გეომეტრიული ფიგურა და ტექსტი, რითაც ხდება ახალი ფუნქციონალის პრაქტიკული დემონსტრირება და ვალიდაცია.

### 🔄 Changed (შეცვლილი და გაუმჯობესებული ფუნქციონალი)

- **refactor(wifi_manager):** 🧠 სრულად გადაკეთდა `FMW_EVENT_WIFI_STATUS_READY` ივენთის `payload`-ის შექმნის ლოგიკა `wifi_cmd_handler`-ში.
  - **პრობლემა:** `payload`-ის `json_data` ველი მიუთითებდა ლოკალურ, დროებით ბუფერზე, რომელიც ნადგურდებოდა ფუნქციის დასრულებისთანავე, რაც იწვევდა სისტემის კრახს (`dangling pointer`).
  - **გამოსავალი:** ახლა იქმნება სრულფასოვანი, დინამიურად გამოყოფილი `fmw_telemetry_payload_t` სტრუქტურა, რომლის სიცოცხლის ციკლსაც `Event Bus`-ის `reference counting` მექანიზმი მართავს. **ეს სრულად აგვარებს სისტემის არასტაბილურობის პრობლემას.**

### 🐛 Fixed (გამოსწორებული შეცდომები)

- **fix(displays):** 🐞 გასწორდა მრავალი კომპილაციის შეცდომა `ssd1306` მოდულში, რომლებიც გამოწვეული იყო არასწორი `Forward Declaration`-ებით, ფუნქციების სიგნატურების შეუსაბამობით და `enum` ტიპების არასწორი გამოყენებით.
- **fix(interfaces):** 📝 განახლდა `ssd1306_interface.h` ფაილი, რათა სრულად ასახავდეს ახალ, გაფართოებულ გრაფიკულ API-ს.

---

## [5.1.0] - 2025-07-28

🎉 **ვერსია 5.1.0: აპარატურული ინტეგრაციის ერა — I2C და OLED დისპლეი!** 🎉

ეს ვერსია წარმოადგენს უმნიშვნელოვანეს ნაბიჯს Synapse Framework-ის განვითარებაში, რომელიც პლატფორმას აძლევს ფიზიკურ სამყაროსთან ურთიერთქმედების ახალ, მძლავრ შესაძლებლობებს. დაემატა ფუნდამენტური I2C დრაივერი და სრულფასოვანი OLED დისპლეის მოდული, რამაც გზა გაუხსნა სენსორებისა და აქტუატორების ფართო სპექტრის ინტეგრაციას. პარალელურად, მნიშვნელოვნად გაუმჯობესდა არსებული სისტემური მოდულების საიმედოობა და არქიტექტურული სისწორე.

### ✨ Added (დამატებული ფუნქციონალი)

- **feat(drivers):** 🚌 დაემატა ახალი, ფუნდამენტური **`i2c_bus`** მოდული.
  - **თანამედროვე დრაივერი:** იმპლემენტაცია სრულად ეფუძნება ESP-IDF v5.x-ის ახალ, `i2c_master.h` დრაივერს, რაც უზრუნველყოფს მაღალ წარმადობასა და მომავალთან თავსებადობას.
  - **რესურსების სრული მართვა:** `init` ფაზაში, `Resource Manager`-ის მეშვეობით ექსკლუზიურად კეტავს (lock) როგორც I2C პორტს, ისე SDA/SCL GPIO პინებს, რაც გამორიცხავს აპარატურულ კონფლიქტებს.
  - **ნაკად-უსაფრთხო Service API:** აწვდის `i2c_bus_api_t` სერვისს, რომლის ყველა ოპერაცია (`write`, `read`, `scan`) დაცულია `Mutex`-ით, რაც უზრუნველყოფს I2C ავტობუსის უსაფრთხო გამოყენებას მრავალტასკიან გარემოში.

- **feat(displays):** 📺 დაემატა ახალი, სრულფასოვანი **`ssd1306_oled_display`** მოდული.
  - **ვიზუალური ინტერფეისი:** უზრუნველყოფს 128x64 OLED ეკრანის მართვას და სისტემისთვის ვიზუალური უკუკავშირის დამატებას.
  - **დინამიური სტატუსის ბარი:** ეკრანის ზედა ნაწილში მუდმივად გამოისახება "synapse" ლოგო და WiFi კავშირის სტატუსის იკონკა, რომელიც რეალურ დროში ასახავს სიგნალის სიძლიერეს.
  - **მოთხოვნა-პასუხის პატერნი:** `System Timer`-ის მეშვეობით, პერიოდულად და "ჩუმად" (`--silent` რეჟიმში) ითხოვს WiFi სტატუსს, რაც უზრუნველყოფს ეკრანის ეფექტურ განახლებას ლოგების "დასპამვის" გარეშე.
  - **მრავალფეროვანი ფონტები:** მხარს უჭერს როგორც დიდ (8x16), ისე პატარა (6x8) ფონტებს, რაც იძლევა ინფორმაციის იერარქიულად გამოტანის საშუალებას.
  - **Service API და Event Handling:** აწვდის `ssd1306_api_t` სერვისს და გამოიწერს სისტემურ ივენთებს, რაც მას ფრეიმვორქის სრულფასოვან წევრად აქცევს.

### 🔄 Changed (შეცვლილი და გაუმჯობესებული ფუნქციონალი)

- **improve(wifi_manager):** 🤫 `wifi status` CLI ბრძანებას დაემატა `--silent` არგუმენტის მხარდაჭერა. ამ რეჟიმში, მოდული აქვეყნებს `FMW_EVENT_WIFI_STATUS_READY` ივენთს, მაგრამ კონსოლში აღარ ბეჭდავს სტატუსის სრულ ტექსტს.
- **refactor(wifi_manager):** 🧠 სრულად გადაკეთდა `FMW_EVENT_WIFI_STATUS_READY` ივენთის `payload`-ის შექმნის ლოგიკა. ახლა ის იყენებს დინამიურად გამოყოფილ `fmw_telemetry_payload_t` სტრუქტურას და `fmw_telemetry_payload_free` გასუფთავების ფუნქციას, რაც სრულად **აგვარებს "dangling pointer" პრობლემას** და სისტემის კრახს.
- **improve(health_monitor):** ❤️ `health_monitor` მოდული გახდა "ჭკვიანი" და კონტექსტის მიმართ მგრძნობიარე.
  - **Provisioning რეჟიმი:** მოდული გამოიწერს `PROV_STARTED` და `PROV_ENDED` ივენთებს. BLE provisioning-ის აქტიურ ფაზაში, ის **დროებით თიშავს** მეხსიერების (heap) შემოწმებას, რათა თავიდან აიცილოს ცრუ განგაშები Bluetooth სტეკის მიერ გამოწვეული მეხსიერების დროებითი, მაგრამ ლეგიტიმური დატვირთვის გამო.

### 🐛 Fixed (გამოსწორებული შეცდომები)

- **fix(core):** 🐞 აღმოიფხვრა კრიტიკული `Guru Meditation Error (LoadProhibited)`, რომელიც გამოწვეული იყო `wifi_manager`-ის მიერ `Event Bus`-ზე არასწორად ფორმირებული და ნაადრევად განთავისუფლებული `payload`-ის გაგზავნით.
- **fix(displays):** 🖼️ გასწორდა `ssd1306` მოდულში ტექსტის 90 გრადუსით შემობრუნების და გაურკვეველი სიმბოლოების პრობლემა, ფონტების მონაცემების კორექტული დამუშავებით.
- **fix(build):** 🛠️ მოგვარდა მრავალი კომპილაციისა და linking-ის შეცდომა, რომლებიც დაკავშირებული იყო არასწორ `#include`-ებთან, `enum` და სტრიქონული ივენთების ტიპების შეუსაბამობასთან და `CMakeLists.txt`-ში ფაილების არასრულ სიასთან.

---

## [5.0.1] - 2025-07-01

### ✨ Added (დამატებული ფუნქციონალი)

- **Command Router:**
  - `Command Router`-ის Service API-ს დაემატა ახალი ფუნქცია: `bool is_command_registered(const char *command_name)`. ეს ფუნქცია საშუალებას აძლევს მოდულებს, შეამოწმონ, არის თუ არა კონკრეტული ბრძანება უკვე რეგისტრირებული, რაც კრიტიკულია მრავალი ინსტანციის მქონე მოდულებისთვის კონფლიქტების თავიდან ასაცილებლად.

### 🔄 Changed (შეცვლილი ფუნქციონალი)

- **Relay Actuator (`relay_actuator`):**
  - სრულად შეიცვალა CLI ბრძანების რეგისტრაციის ლოგიკა. ახლა, `relay_actuator`-ის თითოეული ინსტანცია `FMW_EVENT_SYSTEM_START_COMPLETE` ივენთის მიღებისას ამოწმებს, არის თუ არა ზოგადი `"relay"` ბრძანება უკვე რეგისტრირებული. ბრძანებას არეგისტრირებს მხოლოდ პირველი ინსტანცია, რითაც სრულად გვარდება ბრძანების სახელის კონფლიქტის პრობლემა.
  - **(მომავალი განვითარებისთვის)** მომზადდა საფუძველი `relay_api_t` სერვისის დასამატებლად, რაც სხვა მოდულებს მისცემს რელეს პირდაპირი პროგრამული მართვის საშუალებას.

### 🐛 Fixed (გამოსწორებული შეცდომები)

- **Watchdog Manager (`watchdog_manager`):**
  - გამოსწორდა კრიტიკული შეცდომა `watchdog_manager_create` ფუნქციაში, რის გამოც მოდული `module_registry`-ში რეგისტრირდებოდა ცარიელი სახელით. ახლა ის სწორად კითხულობს და ანიჭებს `instance_name`-ს `config.json`-იდან.
- **MQTT Heartbeat (`mqtt_manager` & `connectivity_watchdog`):**
  - გამოსწორდა ლოგიკა `mqtt_manager`-ში. ახლა ის, `MQTT_HEARTBEAT_TICK` ივენთის მიღებისას, სწორად აქვეყნებს `FMW_EVENT_CONNECTIVITY_ESTABLISHED` ივენთს, რაც აგვარებს `Connectivity Watchdog`-ის მიერ გენერირებული `TIMEOUT` გაფრთხილებების პრობლემას.

## [5.0.0] - 2025-07-01

### 💥 Breaking Changes

- **არქიტექტურა: დაინერგა დეცენტრალიზებული კონფიგურაციის მოდელი.**
  - **`system_config.json`**-ის როლი შეიცვალა. ის ახლა შეიცავს მხოლოდ გლობალურ პარამეტრებს (`firmware`, `global_config`) და ცარიელ `modules` მასივს. მოდულების კონფიგურაციები ამ ფაილიდან სრულად ამოღებულია.
  - თითოეულ მოდულს დაემატა საკუთარი **`config.json`** ფაილი, რომელიც განსაზღვრავს მის default runtime კონფიგურაციას. ეს ფაილი შეიძლება შეიცავდეს როგორც ერთ ობიექტს, ისე ობიექტების მასივს მოდულის მრავალი ინსტანციის შესაქმნელად.
  - **`Config Manager`** (`config_manager.c`) სრულად გადაკეთდა. პირველი ჩატვირთვისას, ის firmware-ში ჩაშენებული `system_config.json`-ისა და ყველა მოდულის `config.json`-ისგან დინამიურად "აწყობს" სრულ კონფიგურაციას, რომელსაც შემდეგ ინახავს NVS-ში. ეს სრულად აგვარებს NVS-ის 4KB-იანი ლიმიტის პრობლემას და ფრეიმვორქს ბევრად მასშტაბირებადს ხდის.
  - **მოდულის შექმნის კონტრაქტი (`_create` ფუნქცია) შეიცვალა.** `_create` ფუნქცია ახლა იღებს თავისი კონფიგურაციის ობიექტის **მფლობელობას** (`ownership`) და პასუხისმგებელია მის გათავისუფლებაზე `_deinit` ფუნქციაში. მოდულებმა აღარ უნდა მოახდინონ გადაცემული `config` ობიექტის დუბლირება.

### ✨ Added (დამატებული ფუნქციონალი)

- **Build სისტემა:**
  - დაემატა ახალი CMake სკრიპტი **`collect_configs.cmake`**, რომელიც build-დროში ავტომატურად პოულობს ყველა `config.json` ფაილს, ამატებს მათ firmware-ში და აგენერირებს `embedded_configs.h` "მანიფესტს" `Config Manager`-ისთვის.
- **მოდულის გენერატორი (`create_module.py`):**
  - სკრიპტი განახლდა v3.0-მდე. ახლა ის ავტომატურად აგენერირებს `config.json` ფაილის შაბლონს ახალი მოდულის შექმნისას.
  - განახლდა C კოდის შაბლონები, რათა შეესაბამებოდეს მეხსიერების მართვის ახალ წესებს.
- **დიაგნოსტიკა:**
  - `command_router`-ს დაემატა `nvs_inspect` ბრძანება, რომელიც ბეჭდავს `synapse_cfg` namespace-ში არსებულ ყველა key-value წყვილს, რაც მნიშვნელოვნად ამარტივებს კონფიგურაციის პრობლემების დიაგნოსტიკას.

### 🔄 Changed (შეცვლილი ფუნქციონალი)

- **`module_registry.c`:**
  - რეფაქტორინგის შედეგად, `module_registry` აღარ ამოწმებს `enabled` ფლაგს `config.json`-ში. მოდულის ჩართვა/გამორთვა build-დროში სრულად იმართება `Kconfig`-ით, რაც ამარტივებს ლოგიკას და ქმნის "სიმართლის ერთ წყაროს".
- **`watchdog_manager.c`:**
  - გამოსწორდა შეცდომა `_create` ფუნქციაში, რის გამოც მოდული `module_registry`-ში უსახელოდ რეგისტრირდებოდა.
- **დოკუმენტაცია:**
  - განახლდა პროექტის თითქმის ყველა ძირითადი დოკუმენტი (`README.md`, `directory_structure.md`, `configuration_flow.md`, `module_architecture.md`, `tutorials`, `conventions` და ა.შ.), რათა ასახავდეს ახალ, დეცენტრალიზებულ არქიტექტურას.

### 🐛 Fixed (გამოსწორებული შეცდომები)

- გამოსწორდა კრიტიკული შეცდომა, რომელიც იწვევდა სისტემის კრახს (`ESP_ERR_INVALID_STATE` `esp_event_loop_create_default`-ში), რაც გამოწვეული იყო კონფიგურაციის არასრული ჩატვირთვის გამო მოდულების დუბლირებული შექმნის მცდელობით.
- გამოსწორდა `config_manager.c`-ში არსებული შეცდომები, რომლებიც დაკავშირებული იყო ESP-IDF v5.x-ის NVS იტერატორის API-ს არასწორ გამოყენებასთან.

## [4.2.0] - 2025-07-18

### ✨ დამატებულია (Added)

- **სრული ინტერაქტიული რეჟიმი:** `create_module.py` სკრიპტს დაემატა სრულფასოვანი ინტერაქტიული რეჟიმი. თუ სკრიპტი გაეშვება არგუმენტების გარეშე, ის მომხმარებელს ეტაპობრივად ეკითხება ყველა საჭირო პარამეტრს (სახელი, კატეგორია, არქეტიპი, აღწერა, `init_level`) და სთავაზობს მზა, დანომრილ ვარიანტებს, რაც ამარტივებს გამოყენებას და ამცირებს შეცდომების რისკს.
- **მოდულის არქეტიპები (Archetypes):** დაემატა 7 სხვადასხვა არქეტიპის მხარდაჭერა, რაც საშუალებას იძლევა, დაგენერირდეს კონკრეტული ამოცანისთვის გამზადებული კოდის შაბლონები:
  - `Basic`: მინიმალური შაბლონი.
  - `Event Producer`: ტასკის შექმნით და ივენთის გამოქვეყნების ლოგიკით.
  - `Service Provider`: Service API-ს სტრუქტურით და სერვისის რეგისტრაციის ლოგიკით.
  - `Command Handler`: CLI ბრძანების სტრუქტურით და რეგისტრაციის ლოგიკით.
  - ჰიბრიდული არქეტიპები (`Event & Service`, `Event & Command`, `Service & Command`).
- **ESP-IDF დამოკიდებულებების მართვა:** დაემატა `--deps` პარამეტრი, რომელიც საშუალებას იძლევა, მივუთითოთ ESP-IDF-ის კომპონენტებზე დამოკიდებულებები. ეს დამოკიდებულებები ავტომატურად ემატება გენერირებული `CMakeLists.txt` ფაილის `REQUIRES` სექციაში.
- **`README.md`-ის "ჭკვიანი" გენერაცია:** სკრიპტი ახლა აგენერირებს `README.md` ფაილის შაბლონს, რომლის სტრუქტურა მორგებულია არჩეულ არქეტიპზე და უკვე შეიცავს შესაბამის სექციებს (მაგ., `Service API`, `CLI ბრძანებები`).
- **`init_level`-ის ინტეგრაცია:** `init_level` პარამეტრი ახლა ავტომატურად ემატება როგორც `module.json` ფაილში, ისე `_create` ფუნქციის იმპლემენტაციაში.
- **`mqtt_interface`-ის დამატება:** `module.json`-ის შაბლონს დაემატა ცარიელი `mqtt_interface` სექცია, რაც უზრუნველყოფს სტრუქტურის ერთგვაროვნებას.

### 🔄 შეცვლილია (Changed)

- **`CMakeLists.txt` გენერაციის ლოგიკა:** აღდგენილია და გაუმჯობესებულია სამ-ეტაპიანი, სტაბილური პირობითი კომპილაციის ლოგიკა, რომელიც კორექტულად მუშაობს როგორც `configure`, ისე `build` ეტაპზე.
- **`Kconfig` გენერაციის ლოგიკა:** აღდგენილია `_DEFAULT_INSTANCE_NAME` და `_INSTANCE_NAME_MAX_LEN` პარამეტრების გენერაცია, რაც მოდულის კონფიგურაციას უფრო მოქნილს ხდის.
- **ცვლადების დასახელება:** გენერირებულ C კოდში გასწორდა ცვლადების სახელები (`g_instance` -> `global_{module_name}_instance`, `s_cmd` -> `{module_name}_command_definition`), რათა სრულად შეესაბამებოდეს პროექტის `variable_naming.md` კონვენციას.
- **კატეგორიების სია:** განახლდა და დაზუსტდა ხელმისაწვდომი კატეგორიების სია, რათა ასახავდეს პროექტის ამჟამინდელ სტრუქტურას.

### 🐞 გასწორებულია (Fixed)

- გასწორდა ხარვეზი, როდესაც `Command Handler` არქეტიპის არჩევისას არ გენერირდებოდა `cmd_t` სტრუქტურის დეკლარაცია.
- გასწორდა ლოგიკა `handle_event` ფუნქციაში, რათა `register_command` გამოძახებისას გამოიყენებოდეს ფაილის დონეზე დეკლარირებული `cmd_t` სტრუქტურა და არა ლოკალური `static` ცვლადი.

## [v4.1.0] - 2025-07-19

### ✨ ახალი ფუნქციები (Features)

- **feat(system):** 🐕 დაემატა და სრულად დაინერგა **`watchdog_manager`** მოდული.
  - **აპლიკაციაზე-მორგებული მონიტორინგი:** მოდული უზრუნველყოფს სისტემის დაცვას პროგრამული გაჭედვისგან. ის "კვებავს" ESP-IDF-ის Task Watchdog Timer-ს (TWDT) მხოლოდ იმ შემთხვევაში, თუ ყველა რეგისტრირებული კრიტიკული მოდული დროულად აგზავნის "გულისცემის" (heartbeat) სიგნალს.
  - **Service API:** აწვდის `watchdog_api_t` სერვისს, რომელიც სხვა მოდულებს საშუალებას აძლევს, დაირეგისტრირონ მონიტორინგზე და გააგზავნონ "გულისცემა".
  - **ეფექტური იმპლემენტაცია:** ცალკე ტასკის ნაცვლად, მოდული იყენებს `System Timer Service`-ს პერიოდული შემოწმებებისთვის, რაც ზოგავს სისტემურ რესურსებს.
  - **ივენთზე-დაფუძნებული შეტყობინება:** რომელიმე მოდულის "გაჭედვის" შემთხვევაში, აქვეყნებს `FMW_EVENT_HEARTBEAT_MISSED` ივენთს, რაც იძლევა პრობლემის დეტალური ლოგირების და ანალიზის საშუალებას გადატვირთვამდე.

### ✨ გაუმჯობესებები (Improvements)

- **improve(core):** 🏗️ `core` კომპონენტში დაემატა ახალი, ფრეიმვორქის დონის ივენთები: `FMW_EVENT_WATCHDOG_CHECK_TICK` და `FMW_EVENT_HEARTBEAT_MISSED`.

### 🐛 შესწორებები (Bug Fixes)

- **fix(watchdog):** ⚙️ სრულად გადაკეთდა `watchdog_manager`-ის საწყისი იმპლემენტაცია. აღმოიფხვრა `race condition` და TWDT-სთან დაკავშირებული არასწორი ლოგიკა. ახალი ვერსია იყენებს `System Timer`-ს და კორექტულად ამატებს მონიტორინგზე საკუთარ ტასკს, რაც უზრუნველყოფს მის საიმედო და პროგნოზირებად მუშაობას.
- **fix(build):** 🛠️ გასწორდა `watchdog_manager`-ის `Kconfig` ფაილი. დაემატა დაკარგული კონფიგურაციის პარამეტრები (`CHECK_INTERVAL_MS`, `HEARTBEAT_TIMEOUT_MS`) და ამოღებულ იქნა არასაჭირო პარამეტრები, რომლებიც დაკავშირებული იყო წაშლილ FreeRTOS ტასკთან.

### 📄 დოკუმენტაცია (Documentation)

- **docs(watchdog):** ✍️ შეიქმნა `watchdog_manager`-ის სრული `README.md` ფაილი, რომელიც დეტალურად აღწერს მის არქიტექტურას, Service API-ს, კონფიგურაციას და გამოყენების მაგალითებს.
- **docs(interfaces):** 🔗 შეიქმნა `watchdog_interface.h` და განახლდა `service_types.h` და `framework_events.h` ახალი სერვისისა და ივენთების დასამატებლად.

## [v4.0.0] - 2025-07-19

### ✨ ახალი ფუნქციები (Features)

- **feat(actuators):** 🔌 დაემატა ახალი, სრულფასოვანი მოდული **`relay_actuator`**.
  - **ფიზიკური მართვა:** უზრუნველყოფს ელექტრომექანიკური რელეს მართვას GPIO პინის საშუალებით, რაც ფრეიმვორქს აძლევს ფიზიკურ სამყაროზე ზემოქმედების უნარს.
  - **მრავალი ინსტანციის მხარდაჭერა:** არქიტექტურა საშუალებას იძლევა, სისტემაში ერთდროულად იმართოს რამდენიმე, ერთმანეთისგან დამოუკიდებელი რელე, თითოეული საკუთარი უნიკალური `instance_name`-ით.
  - **CLI ინტეგრაცია:** ამატებს `relay <instance_name> <on|off|toggle>` ბრძანებას, რომელიც `Command Router`-ის მეშვეობით იძლევა ნებისმიერი რელეს ინტერაქტიული მართვის საშუალებას.
  - **მდგომარეობის შენახვა:** `initial_state: "last"` კონფიგურაციის გამოყენებისას, მოდული იყენებს `Storage Manager`-ს, რათა შეინახოს და გადატვირთვის შემდეგ აღადგინოს თავისი ბოლო მდგომარეობა.
  - **სტატუსის გამოქვეყნება:** მდგომარეობის ყოველი ცვლილებისას, აქვეყნებს `FMW_EVENT_RELAY_STATE_CHANGED` ივენთს, რაც უზრუნველყოფს სტატუსის ავტომატურ გავრცელებას MQTT-ით.

- **feat(security):** 🛡️ დაემატა ახალი, ფუნდამენტური მოდული **`security_status_reporter`**.
  - **უსაფრთხოების მონიტორინგი:** სისტემის გაშვებისას კითხულობს და აკეშირებს მოწყობილობის აპარატურული უსაფრთხოების კრიტიკულ სტატუსებს: **Secure Boot**-ისა და **Flash Encryption**-ის მდგომარეობას.
  - **Service API:** არეგისტრირებს `FMW_SERVICE_TYPE_SECURITY_API` სერვისს, რომელიც სხვა მოდულებს საშუალებას აძლევს, პროგრამულად გადაამოწმონ, მუშაობს თუ არა მოწყობილობა დაცულ რეჟიმში.
  - **CLI და MQTT ინტეგრაცია:** ამატებს `security status` ბრძანებას და შესაბამის `FMW_EVENT_SECURITY_STATUS_READY` ივენთს, რაც უზრუნველყოფს სტატუსის დისტანციურად, MQTT-ით მიღების შესაძლებლობას.

### ✨ გაუმჯობესებები (Improvements)

- **improve(mqtt):** 🛰️ `mqtt_manager`-ის თემების გენერაციის ლოგიკა გაუმჯობესდა. მას ახლა შეუძლია, დაამუშაოს თემის შაბლონში არსებული `{module_name}` placeholder-ი და ჩაანაცვლოს ის ივენთის `payload`-იდან მოსული კონკრეტული `instance_name`-ით. ეს კრიტიკულად მნიშვნელოვანია `relay_actuator`-ის მსგავსი, მრავალი ინსტანციის მქონე მოდულების მხარდაჭერისთვის.
- **improve(selftest):** ախ `self_test_manager` მოდული სრულად ინტეგრირდა ახალ `security_status_reporter` სერვისთან. `selftest` რეპორტს დაემატა უსაფრთხოების შემოწმების სექცია.

### 📄 დოკუმენტაცია (Documentation)

- **docs(modules):** ✍️ შეიქმნა სრული `README.md` ფაილები ახალი მოდულებისთვის: `relay_actuator`, `security_status_reporter`.
- **docs(api):** ✍️ შეიქმნა და დაინდექსდა ახალი API დოკუმენტები: `relay_api.md` და `security_api.md`.
- **docs(patterns):** 📖 განახლდა `communication_patterns.md` დოკუმენტაცია, სადაც დაემატა დინამიური MQTT თემების პატერნის და `relay` ბრძანების სრული ციკლის დიაგრამის აღწერა.

## [v3.9.0] - 2025-07-18

### ✨ ახალი ფუნქციები (Features)

- **feat(security):** 🛡️ დაემატა ახალი, ფუნდამენტური მოდული **`security_status_reporter`**.
  - **უსაფრთხოების მონიტორინგი:** მოდული სისტემის გაშვებისას კითხულობს და აკეშირებს მოწყობილობის აპარატურული უსაფრთხოების კრიტიკულ სტატუსებს: **Secure Boot**-ისა და **Flash Encryption**-ის მდგომარეობას.
  - **Service API:** არეგისტრირებს `FMW_SERVICE_TYPE_SECURITY_API` სერვისს, რომელიც სხვა მოდულებს საშუალებას აძლევს, პროგრამულად გადაამოწმონ, მუშაობს თუ არა მოწყობილობა დაცულ რეჟიმში.
  - **CLI ინტეგრაცია:** ამატებს `security status` ბრძანებას, რომელიც კონსოლში გამოიტანს უსაფრთხოების მიმდინარე სტატუსს.
  - **დისტანციური რეპორტინგი:** `security status` ბრძანების გამოძახებისას, მოდული ასევე აქვეყნებს `FMW_EVENT_SECURITY_STATUS_READY` ივენთს JSON `payload`-ით, რაც უზრუნველყოფს სტატუსის დისტანციურად, MQTT-ით მიღების შესაძლებლობას.

### ✨ გაუმჯობესებები (Improvements)

- **improve(selftest):** ախ `self_test_manager` მოდული სრულად ინტეგრირდა ახალ `security_status_reporter` სერვისთან.
  - **უსაფრთხოების შემოწმება:** `selftest` რეპორტს დაემატა ახალი სექცია, რომელიც ამოწმებს და ასახავს Secure Boot-ისა და Flash Encryption-ის სტატუსს. ეს საშუალებას გვაძლევს, ავტომატურად დავრწმუნდეთ, რომ წარმოებისთვის გამზადებული მოწყობილობა სრულად დაცულია.
  - **არგუმენტების გაფართოება:** `selftest --run` ბრძანებას დაემატა ახალი არგუმენტი `security`, კონკრეტულად უსაფრთხოების ტესტების გასაშვებად.

### 📄 დოკუმენტაცია (Documentation)

- **docs(security):** ✍️ შეიქმნა `security_status_reporter`-ის სრული `README.md` ფაილი, რომელიც დეტალურად აღწერს მის არქიტექტურას, API-ს, CLI ბრძანებას და რაც მთავარია, შეიცავს ინსტრუქციას, თუ როგორ უნდა ჩაირთოს Secure Boot და Flash Encryption ESP-IDF-ში.
- **docs(interfaces):** ✍️ შეიქმნა `security_status_interface.h` ფაილი და განახლდა `service_types.h` ახალი სერვისის ტიპის დასამატებლად.

## [v3.8.0] - 2025-07-18

### ✨ ახალი ფუნქციები (Features)

- **feat(aggregator):** 💾 `Sensor Aggregator` მოდულს დაემატა **Offline ბუფერიზაციის** მძლავრი მექანიზმი.
  - **მონაცემების არდაკარგვის გარანტია:** როდესაც მოწყობილობა კარგავს კავშირს (`FMW_EVENT_CONNECTIVITY_LOST`), აგრეგატორი წყვეტს ივენთების გამოქვეყნებას და ამის ნაცვლად, ინახავს აგრეგირებულ რეპორტებს ლოკალურ ფაილურ სისტემაში (`SPIFFS` ან `SD Card`) `Storage Manager`-ის მეშვეობით.
  - **ავტომატური სინქრონიზაცია:** კავშირის აღდგენისას (`FMW_EVENT_CONNECTIVITY_ESTABLISHED`), მოდული ავტომატურად კითხულობს ყველა შენახულ რეპორტს, თანმიმდევრულად აქვეყნებს მათ `Event Bus`-ზე და შემდეგ შლის დამუშავებულ ფაილებს.
  - **კონფიგურირებადობა:** ბუფერიზაციის ჩართვა/გამორთვა, ქეშის დირექტორია და შენახული ფაილების მაქსიმალური რაოდენობა იმართება `Kconfig`-ის საშუალებით.

### ✨ გაუმჯობესებები (Improvements)

- **improve(aggregator):** 🧠 გაუმჯობესდა და დაიხვეწა **"ჭკვიანი" აგრეგაციის** ლოგიკა.
  - **მონაცემთა ვალიდაცია:** `handle_event` ფუნქცია ახლა ამოწმებს შემოსულ მონაცემებს კონფიგურაციაში მითითებულ `valid_range`-თან და აიგნორებს დიაპაზონს გარეთ არსებულ მნიშვნელობებს.
  - **აგრეგაციის რეჟიმები:** სრულად იმპლემენტირდა `avg`, `min`, `max` და `last` რეჟიმები, რომლებიც კორექტულად ამუშავებენ დაგროვილ მონაცემებს `publish_report` ფუნქციაში.

### 🐛 შესწორებები (Bug Fixes)

- **fix(aggregator):** 🐞 აღმოიფხვრა `format-truncation` შეცდომა, რომელიც გამოწვეული იყო ფაილური გზის სიგრძის არასწორი გამოთვლით. `publish_buffered_reports` ფუნქციაში დაინერგა ბუფერის ზომის უსაფრთხო, ხელით შემოწმების ლოგიკა `snprintf`-ის გამოძახებამდე.
- **fix(aggregator):** 🔧 გასწორდა `%u` და `uint32_t` ტიპების შეუსაბამობის პრობლემა `snprintf`-ში, `%lu` ფორმატის სპეციფიკატორისა და ექსპლიციტური კასტინგის გამოყენებით.
- **fix(ble_prov):** 🧠 მოგვარდა მეხსიერების გაჟონვის პრობლემა `ble_provisioning` მოდულში. Provisioning-ის დასრულების შემდეგ, ახლა ხდება Bluetooth stack-ის სრული დეინიციალიზაცია (`esp_bt_mem_release`), რაც ათავისუფლებს მნიშვნელოვან RAM რესურსს და თავიდან გვაცილებს `Low heap memory` alert-ებს.

### 📄 დოკუმენტაცია (Documentation)

- **docs(aggregator):** ✍️ სრულად განახლდა `sensor_aggregator`-ის `README.md` ფაილი. დაემატა ახალი, ბუფერიზაციის ფუნქციონალის დეტალური აღწერა, კონფიგურაციის პარამეტრები და გამოყენების სცენარები.

## [v3.7.0] - 2025-07-18

### ✨ ახალი ფუნქციები (Features)

- **feat(aggregator):** 🧠 `Sensor Aggregator` მოდულს დაემატა **"ჭკვიანი" აგრეგაციის რეჟიმები**.
  - **მონაცემთა დამუშავება Edge-ზე:** კონფიგურაციაში ახლა შესაძლებელია `aggregation_mode` პარამეტრის მითითება თითოეული სენსორისთვის. მხარდაჭერილია შემდეგი რეჟიმები:
    - `last`: აგზავნის მხოლოდ ბოლო მიღებულ მნიშვნელობას (Default).
    - `avg`: აგზავნის დროის ფანჯარაში მიღებული მნიშვნელობების საშუალო არითმეტიკულს.
    - `min`: აგზავნის მინიმალურ მნიშვნელობას.
    - `max`: აგზავნის მაქსიმალურ მნიშვნელობას.
  - **მონაცემთა ვალიდაცია:** დაემატა `valid_range` პარამეტრის მხარდაჭერა. აგრეგატორი ახლა ავტომატურად ამოწმებს, ჯდება თუ არა სენსორის მონაცემი დასაშვებ დიაპაზონში (`min`/`max`) და აიგნორებს არავალიდურ მნიშვნელობებს, რაც ზრდის სისტემის მდგრადობას.

### 🐛 შესწორებები (Bug Fixes)

- **fix(aggregator):** 🐞 გასწორდა კრიტიკული ბაგი, რომელიც იწვევდა მონაცემების დუბლირებას აგრეგირებულ რეპორტში. `snapshot`-ის შექმნის ლოგიკა სრულად გადაკეთდა: `handle_event` ფუნქცია ახლა იყენებს `cJSON_ReplaceItemInObject`-ს, რათა განაახლოს არსებული მნიშვნელობები, ხოლო `publish_report` ფუნქცია ყოველი გამოქვეყნების შემდეგ სრულად ასუფთავებს დაგროვილ მონაცემებს.
- **fix(aggregator):** 🔧 აღმოიფხვრა `strncpy`-ის არასწორი გამოყენებით გამოწვეული ბუფერის გადავსების რისკი. `output_event_name` პარამეტრი ამოღებულ იქნა კონფიგურაციიდან და ჩანაცვლდა სტანდარტული, ცენტრალიზებული `FMW_EVENT_AGGREGATED_SENSOR_REPORT` ივენთით.

### 📄 დოკუმენტაცია (Documentation)

- **docs(aggregator):** ✍️ სრულად განახლდა `sensor_aggregator`-ის `README.md` ფაილი. დაემატა ახალი კონფიგურაციის პარამეტრების (`aggregation_mode`, `valid_range`) დეტალური აღწერა და მათი შესაძლო მნიშვნელობების ცხრილი.

## [v3.6.0] - 2025-07-17

### ✨ ახალი ფუნქციები (Features)

- **feat(sensors):** 🌡️ დაემატა ახალი, მძლავრი მოდული **`sensor_aggregator`**.
  - **ცენტრალიზებული შეგროვება:** უზრუნველყოფს სხვადასხვა სენსორის მიერ გამოქვეყნებული ივენთების შეგროვებას და ერთ, სტრუქტურირებულ რეპორტად გამოქვეყნებას.
  - **კონფიგურირებადი სტრატეგიები:** მხარს უჭერს მონაცემთა აგრეგაციის ორ ძირითად სტრატეგიას:
    1. **`time_window`**: აგროვებს მონაცემებს და აქვეყნებს რეპორტს ფიქსირებული დროის ინტერვალით.
    2. **`on_trigger`**: აგროვებს მონაცემებს, მაგრამ რეპორტს აქვეყნებს მხოლოდ კონკრეტული, "გამომწვევი" ივენთის მიღებისას.
  - **სისტემურ სერვისებთან ინტეგრაცია:** აქტიურად იყენებს `System Timer Service`-ს დროზე-დაფუძნებული აგრეგაციისთვის და `Event Bus`-ს მონაცემების მისაღებად და გასაგზავნად.
  - **MQTT ინტეგრაცია:** `module.json`-ში `mqtt_interface`-ის განსაზღვრის წყალობით, მისი აგრეგირებული რეპორტები ავტომატურად ქვეყნდება MQTT-ში.

- **feat(testing):** 🧪 დაემატა ახალი სატესტო მოდული **`sensor_simulator`**.
  - **აპარატურის იმიტაცია:** ფიზიკური სენსორების გარეშე ახდენს ტემპერატურის, ტენიანობის და განათების სენსორების მონაცემების გენერაციის იმიტაციას.
  - **პერიოდული ივენთები:** იყენებს `System Timer Service`-ს, რათა პერიოდულად გამოაქვეყნოს სენსორული ივენთები, რაც იდეალურია `sensor_aggregator`-ის და სხვა "მსმენელი" მოდულების გასატესტად.

### ✨ გაუმჯობესებები (Improvements)

- **improve(core):** 🏛️ ფრეიმვორქის ივენთების სისტემა გაუმჯობესდა. `hardcoded` სტრიქონი `"AGGREGATED_SENSOR_REPORT"` გატანილ იქნა ცენტრალიზებულ `framework_events.h` ფაილში, როგორც `FMW_EVENT_AGGREGATED_SENSOR_REPORT`, რაც ზრდის კოდის საიმედოობას და ამარტივებს მის მართვას.

### 🐛 შესწორებები (Bug Fixes)

- **fix(aggregator):** 🐞 გასწორდა კრიტიკული ბაგი `sensor_aggregator`-ში, რომელიც იწვევდა მონაცემების დუბლირებას აგრეგირებულ რეპორტში. `handle_event` ფუნქციის ლოგიკა შეიცვალა `cJSON_ReplaceItemInObject`-ის გამოსაყენებლად, რაც უზრუნველყოფს, რომ `snapshot`-ში თითოეული სენსორის მხოლოდ ბოლო, განახლებული მნიშვნელობა ინახება.
- **fix(aggregator):** 🔧 მოგვარდა `strncpy`-ის არასწორი გამოყენებით გამოწვეული ბუფერის გადავსების პოტენციური რისკი და "მოჭრილი" ივენთის სახელის პრობლემა. `output_event_name` პარამეტრი ამოღებულ იქნა კონფიგურაციიდან და ჩანაცვლდა სტანდარტული, ცენტრალიზებული მაკროთი.
- **fix(simulator):** 🛠️ გასწორდა კომპილაციის შეცდომები `sensor_simulator` მოდულში საჭირო `#include <string.h>` ჰედერის დამატებით.

### 📄 დოკუმენტაცია (Documentation)

- **docs(aggregator):** ✍️ შეიქმნა `sensor_aggregator` მოდულის სრული, დეტალური `README.md` ფაილი, რომელიც აღწერს მის არქიტექტურას, კონფიგურაციის ყველა პარამეტრს, გამოყენების მაგალითებს და სამომავლო განვითარების პერსპექტივებს.
- **docs(simulator):** ✍️ შეიქმნა `sensor_simulator` მოდულის `README.md` ფაილი, სადაც ახსნილია მისი დანიშნულება და გამოყენების წესი ტესტირების პროცესში.

## [v3.5.0] - 2025-07-16

### ✨ ახალი ფუნქციები (Features)

- **feat(diagnostics):** 🩺 დაემატა ახალი, მძლავრი სისტემური მოდული **`self_test_manager`**.
  - **ცენტრალიზებული დიაგნოსტიკა:** უზრუნველყოფს სისტემის კომპონენტების, სერვისების და პერიფერიის ჯანმრთელობის შემოწმების ერთიან მექანიზმს.
  - **CLI ინტეგრაცია:** ამატებს `selftest` ბრძანებას, რომელიც `Command Router`-ის მეშვეობით იძლევა ტესტების სრული ან ნაწილობრივი ნაკრების გაშვების საშუალებას (`--run [all|core|health|storage|conn]`).
  - **არაბლოკირებადი შესრულება:** ტესტები ეშვება გამოყოფილ FreeRTOS ტასკში, რათა არ დაიბლოკოს სისტემის ძირითადი ნაკადი.
  - **მოთხოვნა-პასუხის ციკლი:** `--report` ბრძანების გამოძახებისას, მოდული, კონსოლში ბეჭდვის პარალელურად, `Event Bus`-ზე აქვეყნებს `FMW_EVENT_SELF_TEST_REPORT_READY` ივენთს, რომლის `payload` არის ტესტის რეპორტი JSON ფორმატში.

### ✨ გაუმჯობესებები (Improvements)

- **improve(mqtt):** 🛰️ `mqtt_manager` მოდული განახლდა, რათა დაამუშაოს `FMW_EVENT_SELF_TEST_REPORT_READY` ივენთი.
  - **ავტომატური პუბლიკაცია:** `mqtt_manager` ახლა ავტომატურად აქვეყნებს `selftest`-ის JSON რეპორტს `.../data/selftest/report` MQTT თემაზე, რაც უზრუნველყოფს დიაგნოსტიკის შედეგების დისტანციურად მიღებას.
  - **განზოგადებული Payload Handling:** `mqtt_manager`-ის ივენთების დამუშავების ლოგიკა გაუმჯობესდა, რათა კორექტულად იმუშაოს სტანდარტულ `fmw_telemetry_payload_t` სტრუქტურასთან.

- **improve(core):** 📦 შეიქმნა და დაინერგა `fmw_telemetry_payload_t` სტრუქტურა და მისი გასუფთავების ფუნქცია (`fmw_telemetry_payload_free`) `event_payloads`-ში. ეს ქმნის ერთიან, სტანდარტულ ფორმატს ყველა იმ ივენთისთვის, რომელსაც JSON მონაცემები გადააქვს.

- **improve(core):** 🛡️ `Service Locator`-ის გამოყენება გაუმჯობესდა `hardcoded` სახელების აღმოფხვრის გზით. მოდულები (`mqtt_manager`, `self_test_manager`) ახლა იყენებენ `fmw_service_lookup_by_type`-ს დამოკიდებული სერვისების მოსაძებნად, რაც კოდს უფრო მოქნილს და არქიტექტურულად სწორს ხდის.

### 🐛 შესწორებები (Bug Fixes)

- **fix(build):** 🛠️ გასწორდა linker-ის შეცდომა (`undefined reference to 'fmw_telemetry_payload_free'`) `core` კომპონენტის `CMakeLists.txt`-ში `event_payloads.c` ფაილის დამატებით.
- **fix(selftest):** 🐞 მოგვარდა `File or path name too long` შეცდომა `storage_manager`-ის ტესტირებისას, `instance_name`-ის კორექტული პარსინგისა და გამოყენების გზით.
- **fix(selftest):** ⚙️ გასწორდა `initializer element is not constant` შეცდომა `cmd_handler`-ში `static cmd_t` სტრუქტურის ინიციალიზაციის ლოგიკის შესწორებით.
- **fix(selftest):** 🧠 აღმოიფხვრა `race condition` და `hardcoded` დამოკიდებულება `run_tests_task`-ში. ტასკი ახლა იღებს თავის კონტექსტს (`module_t*`) უსაფრთხოდ, პარამეტრების გადაცემის სტრუქტურის მეშვეობით.

### 📄 დოკუმენტაცია (Documentation)

- **docs(selftest):** ✍️ შეიქმნა `self_test_manager` მოდულის სრული, დეტალური `README.md` ფაილი, რომელიც აღწერს მის არქიტექტურას, CLI ბრძანებებს, MQTT ინტერფეისს და ახალი ტესტის დამატების მაგალითს.

## [v3.4.0] - 2025-07-13

🎉 **ვერსია 3.4.0: სისტემის მდგრადობის რევოლუცია — უნივერსალური Connectivity Watchdog!** 🎉

ეს ვერსია ამატებს Synapse Framework-ის ერთ-ერთ ყველაზე კრიტიკულ კომპონენტს — `Connectivity Watchdog`-ს. ეს არ არის უბრალოდ "watchdog", არამედ **სისტემის მდგრადობის მართვის უნივერსალური პლატფორმა**, რომელიც უზრუნველყოფს, რომ მოწყობილობა არასდროს დარჩეს "ცოცხალი, მაგრამ იზოლირებული" მდგომარეობაში. დაინერგა ახალი, აბსტრაქტული ივენთების სისტემა, რომელიც ფრეიმვორქს კიდევ უფრო მოქნილს და გაფართოებადს ხდის.

### ✨ ახალი ფუნქციები (Features)

- **feat(watchdog):** 🛰️ დაემატა ახალი, მძლავრი სისტემური მოდული **`connectivity_watchdog`**.
  - **უნივერსალური მონიტორინგი:** მოდული აღარ არის მიბმული კონკრეტულ პროტოკოლზე (როგორიცაა MQTT). ის უსმენს ზოგად, აბსტრაქტულ `FMW_EVENT_CONNECTIVITY_ESTABLISHED` ივენთს, რაც მას თავსებადს ხდის ნებისმიერ არსებულ თუ მომავალ საკომუნიკაციო მოდულთან (MQTT, WebSocket, CoAP და ა.შ.).
  - **მრავალშრიანი შემოწმება:** მხარს უჭერს როგორც პასიურ მონიტორინგს (heartbeat ივენთების მოსმენა), ისე აქტიურ შემოწმებას (მაგ., `PING` კონკრეტულ IP მისამართზე), რაც უზრუნველყოფს ქსელის სრული გზის ვალიდაციას.
  - **კონფიგურირებადი აღდგენის სტრატეგიები:** `system_config.json`-ში შესაძლებელია მრავალი, სხვადასხვა ტიპის შემოწმების დამატება, თითოეულს თავისი ტაიმაუტით და მრავალსაფეხურიანი, ესკალაციაზე დაფუძნებული აღდგენის სტრატეგიით (მაგ., `log_warning` -> `reconnect_service` -> `trigger_alarm` -> `reboot_system`).

- **feat(core):** 🌐 დაინერგა ახალი, ზოგადი **კავშირის ივენთები** (`framework_events.h` და `event_payloads.h`).
  - `FMW_EVENT_CONNECTIVITY_ESTABLISHED`: ამ ივენთს აქვეყნებს ნებისმიერი მოდული, რომელიც ამყარებს კრიტიკულ გარე კავშირს.
  - `FMW_EVENT_CONNECTIVITY_LOST`: ქვეყნდება კავშირის დაკარგვისას.
  - `fmw_connectivity_payload_t`: ახალი `payload` სტრუქტურა, რომელიც გადასცემს ინფორმაციას იმის შესახებ, თუ რომელმა შემოწმებამ (`check_name`) დააფიქსირა კავშირის დამყარება.

### ✨ გაუმჯობესებები (Improvements)

- **improve(mqtt):** 💓 `mqtt_manager` მოდულს დაემატა **პერიოდული "heartbeat"** მექანიზმი.
  - `System Timer Service`-ის გამოყენებით, `mqtt_manager` ახლა პერიოდულად (ყოველ 2 წუთში) აქვეყნებს `FMW_EVENT_CONNECTIVITY_ESTABLISHED` ივენთს, სანამ კავშირი აქტიურია. ეს აგვარებს პრობლემას, როდესაც `Connectivity Watchdog`-ი იწვევდა ცრუ განგაშს ხანგრძლივი "დუმილის" გამო.
  - ეს ცვლილება `mqtt_manager`-ს აქცევს `Connectivity Watchdog`-ის უნივერსალური მოდელის სრულფასოვან მონაწილედ.

- **improve(interfaces):** 📝 შეიქმნა და დაემატა `alarms_manager_interface.h` ფაილი, რომელიც უზრუნველყოფს არქიტექტურულ კონსისტენტურობას და ამზადებს ფრეიმვორქს მომავალი გაფართოებისთვის, სადაც სხვა მოდულებს შეეძლებათ პროგრამულად მართონ განგაშები.

### 🐛 შესწორებები (Bug Fixes)

- **fix(build):** 🛠️ გასწორდა კომპილაციის კრიტიკული შეცდომები, რომლებიც გამოწვეული იყო ახალი ივენთებისა და `payload`-ების არარსებობით.
- **fix(build):** 🐞 მოგვარდა `-Werror=restrict` და `-Werror=format-truncation=` კომპილაციის შეცდომები `connectivity_watchdog`-ში `snprintf`-ის უსაფრთხო გამოყენებით, რაც უზრუნველყოფს ბუფერის გადავსებისგან დაცვას.
- **fix(build):** 🔧 გასწორდა `redefinition of 'timer_service'` შეცდომა `mqtt_manager`-ში, `case` ბლოკებისთვის ლოკალური scope-ების შექმნით.

### 📄 დოკუმენტაცია (Documentation)

- **docs(watchdog):** ✍️ შეიქმნა `connectivity_watchdog` მოდულის სრული, დეტალური `README.md` ფაილი, რომელიც აღწერს მის უნივერსალურ არქიტექტურას, კონფიგურაციის ყველა პარამეტრს და სხვადასხვა პროტოკოლთან ინტეგრაციის მაგალითებს.

## [v3.3.0] - 2025-07-10

🎉 **ვერსია 3.3.0: დისტანციური მართვა MQTT-ით და სისტემური გაუმჯობესებები!** 🎉

ეს ვერსია ამატებს ფრეიმვორქის ერთ-ერთ ყველაზე მოთხოვნად ფუნქციონალს - მოწყობილობის სრულფასოვან დისტანციურ მართვას MQTT პროტოკოლის საშუალებით. დაინერგა ახალი არქიტექტურული პატერნები და გასწორდა კრიტიკული შეცდომები, რაც სისტემას კიდევ უფრო მძლავრს, საიმედოსა და გაფართოებადს ხდის.

### ✨ ახალი ფუნქციები (Features)

- **feat(mqtt):** 🚀 დაემატა ახალი, მძლავრი **`mqtt_manager`** მოდული.
  - **ინტელექტუალური ხიდი:** მოქმედებს როგორც შუამავალი `Event Bus`-სა და MQTT ბროკერს შორის.
  - **Command Forwarder:** ავტომატურად იღებს ბრძანებებს სპეციალური MQTT თემიდან (`.../cmd/in`) და გადაამისამართებს მათ `Command Router`-ში, რაც უზრუნველყოფს ნებისმიერი CLI ბრძანების დისტანციურად შესრულებას.
  - **სტატუსის პუბლიკაცია:** გამოიწერს შიდა სისტემურ ივენთებს (მაგ., `FMW_EVENT_WIFI_STATUS_READY`, `FMW_EVENT_DEVICE_INFO_READY`) და მათ `payload`-ებს აქვეყნებს შესაბამის MQTT თემებზე (`.../state/...`).
  - **ავტომატური იდენტიფიკაცია:** იყენებს `Device Identity Service`-ს უნიკალური `ClientID`-ისა და თემების იერარქიის ავტომატურად შესაქმნელად.

- **feat(core):** 🤖 დაინერგა MQTT თემების ავტომატური გენერაციის სისტემა.
  - **ცენტრალიზებული თემები:** Build-ის დროს, სპეციალური Python სკრიპტი კითხულობს `module.json` ფაილებში აღწერილ `mqtt_interface` სექციებს და აგენერირებს `mqtt_topics_generated.h` ფაილს.
  - **უსაფრთხოება და სიმარტივე:** ეს სრულად აღმოფხვრის `hardcoded` თემებს კოდში და გამორიცხავს ბეჭდვით შეცდომებს, რადგან დეველოპერები იყენებენ გენერირებულ C მაკროებს.

- **feat(wifi, device_identity):** 🔄 დაინერგა მოთხოვნა-პასუხის (Request-Response) მექანიზმი.
  - `wifi status` და `device info` ბრძანებები ახლა, კონსოლში ბეჭდვის გარდა, აქვეყნებენ შესაბამის `..._READY` ივენთებს JSON `payload`-ით, რაც `mqtt_manager`-ს საშუალებას აძლევს, ეს პასუხები MQTT-ით გაავრცელოს.

### 🐛 შესწორებები (Bug Fixes)

- **fix(core):** 🐞 გასწორდა კრიტიკული ლოგიკური შეცდომა `Event Bus`-ის დისპეტჩერში.
  - **პრობლემა:** `dispatch_event_to_subscribers` ფუნქციაში არსებული `if/else if` კონსტრუქცია ხელს უშლიდა ივენთის ერთდროულად მიწოდებას როგორც კონკრეტული, ისე ზოგადი (`*`) გამომწერებისთვის.
  - **გამოსავალი:** `else if` ჩანაცვლდა დამოუკიდებელი `if` პირობით, რამაც სრულად მოაგვარა `device_identity_service`-ის მიერ ივენთის მიუღებლობის პრობლემა.

- **fix(core):** ⚙️ გასწორდა `app_main` ფუნქციის ნაადრევი დასრულებით გამოწვეული არასტაბილურობა.
  - `app_main`-ის ბოლოს დაემატა უსასრულო `while(1)` ციკლი `vTaskDelay`-ით, რაც `main_task`-ს "ცოცხალს" ტოვებს და უზრუნველყოფს `FreeRTOS scheduler`-ის მიერ ყველა ფონური ტასკის გამართულ მუშაობას.

- **fix(build):** 🛠️ მოგვარდა სახელების კონფლიქტი `mqtt_client` მოდულსა და ESP-IDF-ის ამავე სახელწოდების კომპონენტს შორის. მოდულს სახელი შეეცვალა `mqtt_manager`-ით, რაც სრულად აღმოფხვრის კომპილაციის შეცდომებს და კოდს უფრო ლოგიკურს ხდის.

### 📄 დოკუმენტაცია (Documentation)

- **docs(mqtt, wifi, device_identity):** ✍️ შეიქმნა და განახლდა შესაბამისი მოდულების `README.md` ფაილები, რომლებიც დეტალურად აღწერენ ახალ MQTT ინტერფეისს, თემების სტრუქტურას და მოთხოვნა-პასუხის მექანიზმს.
- **docs(api):** ✍️ შეიქმნა და განახლდა `api_reference` დირექტორიის დოკუმენტები (`device_identity_api.md`, `wifi_api.md`, `mqtt_api.md`, `api_index.md`) ახალი ცვლილებების ასასახად.

## [v3.2.1] - 2025-07-08

### ✨ ახალი ფუნქციები (Features)

- **feat(system):** 🆔 დაემატა ახალი, ფუნდამენტური სისტემური მოდული **`device_identity_service`**.
  - **ცენტრალიზებული იდენტობა:** უზრუნველყოფს ერთიან, კეშირებულ წვდომას მოწყობილობის უნიკალურ ID-ზე (MAC მისამართისგან გენერირებული) და firmware-ის ვერსიაზე.
  - **Service API:** აწვდის `device_identity_api_t` სერვისს `Service Locator`-ის მეშვეობით, რაც სხვა მოდულებს (მაგ., `mqtt_client`) საშუალებას აძლევს, მარტივად მიიღონ საიდენტიფიკაციო მონაცემები.
  - **CLI ინტეგრაცია:** ამატებს `device info` ბრძანებას, რომელიც `Command Router`-ის მეშვეობით გამოაქვს მოწყობილობის ID და firmware-ის ვერსია.

### 🐛 შესწორებები (Bug Fixes)

- **fix(core):** 🐞 გასწორდა კრიტიკული ლოგიკური შეცდომა `Event Bus`-ის დისპეტჩერში, რამაც `device_identity_service`-ის გამართული მუშაობა უზრუნველყო.
  - **პრობლემა:** `dispatch_event_to_subscribers` ფუნქციაში არსებული `if/else if` კონსტრუქცია ხელს უშლიდა ივენთის ერთდროულად მიწოდებას როგორც კონკრეტული, ისე ზოგადი (`*`) გამომწერებისთვის. ამის გამო, `device_identity_service` ვერ იღებდა `FMW_EVENT_SYSTEM_START_COMPLETE` ივენთს და ვერ არეგისტრირებდა თავის CLI ბრძანებას.
  - **გამოსავალი:** `else if` ჩანაცვლდა დამოუკიდებელი `if` პირობით, რაც უზრუნველყოფს, რომ ივენთი გარანტირებულად მიეწოდება ყველა შესაბამის გამომწერს.

- **fix(core):** ⚙️ გასწორდა `app_main` ფუნქციის ნაადრევი დასრულებით გამოწვეული არასტაბილურობა.
  - **პრობლემა:** `app_main` ფუნქციის დასრულების შემდეგ, `main_task` ნადგურდებოდა, რაც არ აძლევდა `FreeRTOS scheduler`-ს საკმარის დროს ფონური ტასკების (მაგ., `event_bus_task`) სტაბილური მუშაობისთვის.
  - **გამოსავალი:** `app_main`-ის ბოლოს დაემატა უსასრულო `while(1)` ციკლი `vTaskDelay`-ით, რაც `main_task`-ს "ცოცხალს" ტოვებს და უზრუნველყოფს სისტემის გამართულ მუშაობას.

### ✨ გაუმჯობესებები (Improvements)

- **improve(core):** 💎 დაინერგა "ერთიანი სიმართლის წყაროს" პრინციპი ივენთების სახელებისთვის.
  - **პრობლემა:** ივენთების სახელები (`"FMW_EVENT_SYSTEM_START_COMPLETE"`) კოდში იწერებოდა ხელით, როგორც სტრიქონული ლიტერალები ("magic strings"), რაც ზრდიდა შეცდომის დაშვების რისკს.
  - **გამოსავალი:** ყველა სისტემური ივენთის სახელი გატანილ იქნა ცენტრალიზებულ `framework_events.h` ჰედერში, როგორც მაკროები. შესაბამისი მოდულები (`system_manager`, `wifi_manager`, `device_identity_service`) განახლდა ამ მაკროების გამოსაყენებლად, რაც გამორიცხავს შეუსაბამობას და კოდს ხდის უფრო საიმედოსა და ადვილად სამართავს.

### 📄 დოკუმენტაცია (Documentation)

- **docs(identity):** ✍️ შეიქმნა `device_identity_service` მოდულის დეტალური `README.md` ფაილი, რომელიც აღწერს მის არქიტექტურას, Service API-ს, CLI ბრძანებას და გამოყენების მაგალითებს.
- **docs(api):** 🔗 განახლდა `api_index.md` და შეიქმნა `device_identity_interface.h` შესაბამისი API კონტრაქტის დასამატებლად.

## [v3.2.0] - 2025-07-08

### ✨ ახალი ფუნქციები (Features)

- **feat(system):** 🚨 დაემატა ახალი, მძლავრი სისტემური მოდული **`alarms_manager`**.
  - **ცენტრალიზებული რეაგირება:** უზრუნველყოფს კრიტიკულ სისტემურ ივენთებზე (მაგ., `SYSTEM_HEALTH_ALERT`, `WIFI_EVENT_DISCONNECTED`) რეაგირების ლოგიკის ცენტრალიზებულ მართვას.
  - **წესებზე-დაფუძნებული ძრავი:** მოდულის ქცევა სრულად იმართება `system_config.json`-ში აღწერილი "განგაშის წესებით", რომლებიც განსაზღვრავენ ივენთის გამომწვევ პირობებს, სიხშირეს (`threshold_count`) და დროის ფანჯარას (`time_window_sec`).
  - **კონფიგურირებადი მოქმედებები:** მხარს უჭერს წინასწარ განსაზღვრულ მოქმედებებს, როგორიცაა კრიტიკული ლოგის ჩაწერა, LED ინდიკატორის ფერის შეცვლა და სისტემის უსაფრთხო გადატვირთვა.
  - **რესურსების ოპტიმიზაცია:** მოდულის მიერ გამოყენებული რესურსები (წესების მაქსიმალური რაოდენობა, ბუფერების ზომები) სრულად კონფიგურირებადია `Kconfig`-ის საშუალებით.

### 📄 დოკუმენტაცია (Documentation)

- **docs(alarms):** ✍️ შეიქმნა `alarms_manager` მოდულის დეტალური `README.md` ფაილი, რომელიც აღწერს მის არქიტექტურას, კონფიგურაციის სტრუქტურას, წესებს და გამოყენების სცენარებს.
- **docs(kconfig):** ⚙️ შეიქმნა `Kconfig` ფაილი `alarms_manager`-ისთვის, რომელიც დეტალურად აღწერს ყველა კონფიგურირებად პარამეტრს.
- **docs(api):** 🔗 განახლდა `api_index.md` ახალი მოდულის დოკუმენტაციის დასამატებლად.

## [v3.1.0] - 2025-07-06

### ✨ ახალი ფუნქციები (Features)

- **feat(timer):** ⏱️ დაემატა ახალი, ცენტრალიზებული **`System Timer Service`** (`system_timer`) მოდული.
  - აწვდის Service API-ს (`timer_api_t`) სხვა მოდულებს, რათა მათ შეძლონ ერთჯერადი ან პერიოდული ივენთების დაგეგმვა.
  - იყენებს `esp_timer`-ს მაღალი რეზოლუციისა და ეფექტურობისთვის.
  - აბსტრაგირებს ტაიმერების შექმნისა და მართვის სირთულეს, რაც ამარტივებს პერიოდული ამოცანების იმპლემენტაციას.
  - ამცირებს სისტემაში ერთდროულად არსებული ტაიმერების რაოდენობას და ზოგავს რესურსებს.

- **feat(testing):** 🧪 დაემატა ახალი სატესტო მოდული **`timer_test`**.
  - წარმოადგენს `System Timer` და `RGB LED Indicator` სერვისების ერთობლივი მუშაობის სადემონსტრაციო მაგალითს.
  - გაშვებისას, ყოველ 3 წამში ერთხელ გეგმავს ივენთს, რომელიც ცვლის LED ინდიკატორის ფერს, რითაც ტესტავს ორივე სერვისის API-ს.

### 📄 დოკუმენტაცია (Documentation)

- **docs(timer):** შეიქმნა `system_timer` მოდულის `README.md` ფაილი, რომელიც დეტალურად აღწერს მის არქიტექტურას, API-ს და გამოყენების მაგალითებს.
- **docs(testing):** შეიქმნა `timer_test` მოდულის `README.md` ფაილი, რომელიც ხსნის მის დანიშნულებას და მუშაობის ლოგიკას.
- **docs(api):** განახლდა `api_index.md` და შეიქმნა `timer_interface.h` შესაბამისი API კონტრაქტების დასამატებლად.

## [v3.0.0] - 2025-07-05

🎉 **ვერსია 3.0.0: არქიტექტურული განახლება და მოდულების გაძლიერება!** 🎉

ეს ვერსია წარმოადგენს Synapse Framework-ის მნიშვნელოვან ევოლუციას. მთავარი აქცენტი გაკეთდა მონაცემთა შენახვის სისტემის სრულ რეფაქტორინგზე, მოდულებს შორის დამოკიდებულებების შემცირებასა და ზოგადი საიმედოობის გაზრდაზე.

### ✨ ახალი ფუნქციები (Features)

- **feat(storage):** 🚀 დაემატა ახალი, უნივერსალური **`Storage Manager`** მოდული.
  - მხარს უჭერს მრავალ backend-ს: **NVS**, **SPIFFS** და **SD Card**.
  - Backend-ის არჩევა შესაძლებელია `Kconfig`-იდან, რაც უზრუნველყოფს პროექტის მაქსიმალურ მოქნილობას.
  - აწვდის ერთიან, აბსტრაქტულ Service API-ს როგორც Key-Value, ისე ფაილური ოპერაციებისთვის.

- **feat(ble_prov):** 📲 `ble_provisioning` მოდულს დაემატა საკუთარი **Service API** (`ble_prov_api_t`).
  - სხვა მოდულებს ახლა შეუძლიათ პროგრამულად შეამოწმონ (`is_provisioning_active`) და დაიწყონ (`start_provisioning`) provisioning-ის პროცესი.

- **feat(wifi):** ⌨️ მნიშვნელოვნად გაფართოვდა `wifi` CLI ბრძანების ფუნქციონალი. დაემატა ახალი ქვე-ბრძანებები:
  - `scan`: ხელმისაწვდომი ქსელების სკანირება.
  - `erase_creds`: შენახული WiFi მონაცემების წაშლა.
  - `set_hostname`: მოწყობილობის ქსელური სახელის შეცვლა.
  - `set_power_save`: ენერგიის დაზოგვის რეჟიმის მართვა.

### ♻️ რეფაქტორინგი და გაუმჯობესებები (Refactoring & Improvements)

- **refactor(wifi):** 🔧 `wifi_manager` მოდული სრულად გადაკეთდა ახალი `Storage Manager` სერვისის გამოსაყენებლად. ამან მოაშორა პირდაპირი დამოკიდებულება NVS API-ზე და გაზარდა მოდულის მოქნილობა.
- **refactor(ble_prov):** 🧹 გასუფთავდა და ოპტიმიზირდა `ble_provisioning` მოდულის კოდი. ამოღებულია არასაჭირო `enable`/`disable` ფუნქციები და გამარტივდა ივენთების დამუშავების ლოგიკა.
- **refactor(storage):** ⚙️ `storage_manager`-ის იმპლემენტაცია დაიყო backend-ების მიხედვით (`storage_backend_nvs.c`, `storage_backend_spiffs.c`, `storage_backend_sd.c`), რაც კოდს უფრო სუფთას და მარტივად სამართავს ხდის (Strategy Pattern).

### 🐛 შესწორებები (Bug Fixes)

- **fix(provisioning):** 🐞 გასწორდა კრიტიკული შეცდომა, რომლის დროსაც BLE provisioning-ის პროცესი არ სრულდებოდა კორექტულად მობილურ აპლიკაციაში. ახლა სისტემა ეყრდნობა ESP-IDF-ის შიდა მექანიზმებს წარმატების სიგნალის გასაგზავნად.
- **fix(spiffs):** ❗ გასწორდა შეცდომა, რომელიც იწვევდა `mkdir` ფუნქციის წარუმატებლობას SPIFFS backend-ზე. ამოღებულია დირექტორიის შექმნის არასაჭირო ლოგიკა.
- **fix(rgb_led):** 💡 გასწორდა `race condition` `rgb_led_indicator` მოდულში. ის ახლა იყენებს `ble_provisioning`-ის სერვისს მისი სტატუსის შესამოწმებლად გაშვებისას, იმის ნაცვლად, რომ მხოლოდ ივენთს დაეყრდნოს.
- **fix(build):** 🛠️ გამოსწორდა კომპილაციის მრავალი შეცდომა, რომლებიც დაკავშირებული იყო არასწორ `include`-ებთან, ფუნქციების სახელების კონფლიქტებთან და `Kconfig` ცვლადების არარსებობასთან.

### 📄 დოკუმენტაცია (Documentation)

- **docs(storage):** ✍️ შეიქმნა და განახლდა `storage_manager`-ის `README.md` და `storage_api.md` ფაილები, რომლებიც სრულად ასახავს ახალ, მრავალ-backend-იან არქიტექტურას.
- **docs(ble_prov):** ✍️ შეიქმნა `ble_provisioning`-ის `README.md` ფაილი, რომელიც აღწერს მის ახალ Service API-ს და არქიტექტურულ პრინციპებს.
- **docs(wifi):** ✍️ განახლდა `wifi_manager`-ის `README.md` ფაილი ახალი CLI ბრძანებების სრული აღწერით.
- **docs(convention):** 📖 შეიქმნა ახალი დოკუმენტი `initialization_levels.md`, რომელიც ადგენს მოდულების ინიციალიზაციის თანმიმდევრობის სტანდარტს.

## [2.8.0] - 2025-07-05

### ✨ ახალი ფუნქციები (Features)

- **feat(wifi):** გაფართოვდა `wifi` CLI ბრძანების ფუნქციონალი. დაემატა ახალი ქვე-ბრძანებები: `scan`, `erase_creds`, `set_hostname` და `set_power_save`.
- **feat(wifi):** `wifi status` ბრძანებას ახლა გამოაქვს დეტალური ინფორმაცია, მათ შორის IP, MAC და Hostname.

### 🐛 შესწორებები (Bug Fixes)

- **fix(wifi):** გასწორდა `wifi status` ბრძანების ლოგიკა. ახლა ის კორექტულად ასახავს კავშირის მიმდინარე სტატუსს (`Connected`/`Disconnected`) მოდულის შიდა მდგომარეობის ფლაგის განახლების გზით.

### 📄 დოკუმენტაცია (Documentation)

- **docs(wifi):** განახლდა `wifi_manager`-ის `README.md` ფაილი ახალი CLI ბრძანებების სრული აღწერით.

## [2.7.0] - 2025-07-05

### ✨ ახალი ფუნქციები (Features)

- **feat(rgb_led):** დაემატა CLI (Command Line Interface) ინტეგრაცია `Command Router`-ის მეშვეობით. ახლა შესაძლებელია `rgb_led_indicator` მოდულის სრული მართვა სერიული კონსოლიდან `led` ბრძანების გამოყენებით.
  - მხარდაჭერილია ქვე-ბრძანებები: `set`, `blink`, `pulse`, `off`, `release`.
- **feat(docs):** შეიქმნა ახალი დოკუმენტი `initialization_levels.md`, რომელიც განსაზღვრავს მოდულების ინიციალიზაციის დონეების სტანდარტულ სტრატეგიას.

### 🐛 შესწორებები (Bug Fixes)

- **fix(rgb_led):** გასწორდა `init_level` პარამეტრი `rgb_led_indicator` მოდულისთვის. მნიშვნელობა შეიცვალა `1`-დან `60`-მდე, რათა უზრუნველყოფილ იქნას, რომ მისი ინიციალიზაცია მოხდეს `command_router`-ის (`init_level: 50`) შემდეგ. ეს აგვარებს race condition-ს, როდესაც მოდული ცდილობდა გამოეყენებინა სერვისი, რომელიც ჯერ არ იყო რეგისტრირებული.

### 📄 დოკუმენტაცია (Documentation)

- **docs(rgb_led):** განახლდა `rgb_led_indicator` მოდულის დოკუმენტაცია. დაემატა ახალი სექცია CLI ბრძანებების დეტალური აღწერით და განახლდა არქიტექტურული პრინციპების სექცია `Command Router`-თან ინტეგრაციის ასახსნელად.

## [2.6.0] - 2025-07-04

### ✨ დამატებულია

- **მოდული `command_router`:** დაემატა ახალი, მძლავრი სისტემური მოდული, რომელიც უზრუნველყოფს ბრძანებების ცენტრალიზებულ დამუშავებას და ინტერაქტიულ გარსს (shell).
  - **Service API:** შეიქმნა საჯარო Service API (`cmd_router_api_t`), რომელიც სხვა მოდულებს აძლევს საშუალებას, დინამიურად დაარეგისტრირონ და გააუქმონ საკუთარი ბრძანებები.
  - **ინტერაქტიული სერიული გარსი:** იმპლემენტირებულია გამართული, არაბლოკირებადი სერიული კონსოლი ESP-IDF-ის `esp_console` კომპონენტის გამოყენებით, რაც სრულად აგვარებს UART პორტის კონფლიქტს ლოგირების სისტემასთან.
  - **ივენთზე დაფუძნებული შესრულება:** მოდული გამოიწერს `FMW_EVENT_EXECUTE_COMMAND_STRING` ივენთს, რაც უზრუნველყოფს ბრძანებების პროგრამულად გამოძახებას ნებისმიერი სხვა მოდულიდან (მაგ. MQTT, HTTP).
  - **ჩაშენებული ბრძანებები:** დაემატა საბაზისო ბრძანებები: `help`, `modules`, და `reboot` სისტემის დიაგნოსტიკისა და მართვისთვის.

- **ახალი ინტერფეისები:**
  - `cmd_router_interface.h`: განსაზღვრავს `Command Router`-ის საჯარო API-ს კონტრაქტს.
  - `framework_events.h`: შეიქმნა ცენტრალიზებული ჰედერი სტანდარტიზებული, ფრეიმვორქის დონის ივენთების სტრიქონული იდენტიფიკატორებისთვის.
  - `event_payloads.h`: დაემატა `fmw_command_payload_t` სტრუქტურა ივენთებით ბრძანებების გადასაცემად.
  - `system_manager_interface.h`: შეიქმნა საჯარო Service API `System Manager`-ისთვის, რათა სხვა მოდულებმა კონტროლირებულად მიიღონ წვდომა მოდულების სიაზე.

### 🛠️ შეცვლილია

- **`system_manager`:** ახლა არეგისტრირებს საკუთარ Service API-ს (`system_manager_api_t`), რათა სხვა მოდულებს მიაწოდოს სისტემური ინფორმაცია (მაგ. მოდულების სია) იზოლაციის პრინციპის დარღვევის გარეშე.
- **დასახელების კონვენციები:** გასწორდა ყველა `g_` და სხვა, კონვენციასთან შეუსაბამო ცვლადის სახელი ახალ და არსებულ კოდში, ფრეიმვორქის სტანდარტებთან სრული შესაბამისობისთვის.

### 🐛 გასწორებულია

- **აღმოფხვრილია `Guru Meditation Error`:** გასწორდა `LoadProhibited` პანიკა `command_router`-ის საწყის იმპლემენტაციაში, რომელიც გამოწვეული იყო `argtable`-ის სიცოცხლის ციკლის არასწორი მართვით.
- **აღმოფხვრილია `ESP_ERR_NO_MEM` კონსოლში:** მოგვარდა მეხსიერების გამოყოფის მუდმივი შეცდომები კონსოლში `esp_console`-ის REPL-თან და VFS UART დრაივერთან სწორი ინტეგრაციით.
- **გასწორდა `deprecated` API-ს გაფრთხილებები:** განახლდა VFS და UART ფუნქციების გამოძახებები ESP-IDF v5.x-ის უახლესი, მოძველებული სტატუსის არმქონე API-ების გამოსაყენებლად, რაც უზრუნველყოფს სუფთა, გაფრთხილებების გარეშე ბილდს.

## [v2.5.0] - 2025-07-02

### ✨ ახალი ფუნქციონალი

- **დაემატა Synapse CLI (Command-Line Interface):** შეიქმნა ერთიანი, cross-platform ბრძანებების ხაზის ინსტრუმენტი (`synapse`) პროექტის მართვის, მოდულების გენერაციისა და მოწყობილობასთან ურთიერთქმედების ავტომატიზაციისთვის.
  - **პროექტის მართვა:** დაემატა `synapse project` ჯგუფის ბრძანებები (`build`, `flash`, `monitor`, `clean`), რომლებიც აბსტრაქციას უკეთებენ და ამარტივებენ `idf.py`-სთან მუშაობას.
  - **მოდულების მართვა:** დაემატა `synapse module create` ბრძანება, რომელიც ინტეგრირებულია `create_module.py` სკრიპტთან და უზრუნველყოფს ახალი მოდულების სწრაფ და სტანდარტიზებულ შექმნას.
  - **მოწყობილობასთან ურთიერთქმედება:** დაემატა `synapse device` ჯგუფის ბრძანებები (`shell`, `cmd`, `health`), რომლებიც იყენებენ `Command Router` მოდულის სერიულ კონსოლს მოწყობილობის პირდაპირი მართვისა და დიაგნოსტიკისთვის.
  - **კონფიგურაციის ვალიდატორი:** დაემატა `synapse config validate` ბრძანება, რომელიც ამოწმებს `system_config.json` ფაილის სინტაქსურ სისწორეს და ადარებს მას `module.json`-ებში აღწერილ სქემებს, რაც თავიდან აგვაცილებს კონფიგურაციის შეცდომებს.

## [v2.4.0] - 2025-07-02

### ✨ ახალი ფუნქციონალი

- **დაემატა Watchdog Manager მოდული:** შეიქმნა ახალი სისტემური მოდული, რომელიც უზრუნველყოფს სისტემის დაცვას პროგრამული გაჭედვისგან "ჭკვიანი" მონიტორინგის მეშვეობით.
  - **აპლიკაციაზე მორგებული Watchdog:** მოდული იყენებს ESP-IDF-ის Task Watchdog Timer-ს (TWDT), მაგრამ "კვებავს" მას მხოლოდ იმ შემთხვევაში, თუ ყველა რეგისტრირებული კრიტიკული მოდული გამართულად მუშაობს.
  - **"გულისცემის" (Heartbeat) მექანიზმი:** სხვა მოდულებს შეუძლიათ დაარეგისტრირონ საკუთარი თავი და პერიოდულად გააგზავნონ "გულისცემის" სიგნალი. თუ რომელიმე მოდული შეწყვეტს სიგნალის გაგზავნას, Watchdog-ი გამოიწვევს სისტემის გადატვირთვას.
  - **Service API:** ამატებს `FMW_SERVICE_TYPE_WATCHDOG_API` სერვისს, რომელიც სხვა მოდულებს საშუალებას აძლევს, მართონ თავიანთი რეგისტრაცია და "გულისცემის" გაგზავნა.
  - **კონფიგურირებადობა:** მოდულის შემოწმების ინტერვალი და "გულისცემის" ტაიმაუტი იმართება `system_config.json`-იდან.

### 🐛 შეცდომების გასწორება

- **გასწორდა TWDT-ის ორმაგი ინიციალიზაციის პრობლემა:** `watchdog_manager`-ის `init` ფუნქცია ახლა კორექტულად ამოწმებს, არის თუ არა Task Watchdog Timer-ი უკვე ინიციალიზებული სისტემის მიერ (`menuconfig`-იდან), რაც თავიდან აცილებს `ESP_ERR_INVALID_STATE` შეცდომას და სისტემის კრაშს.

---

## [v2.3.0] - 2025-07-02

### ✨ ახალი ფუნქციონალი

- **დაემატა OTA Update Manager მოდული:** შეიქმნა ახალი სისტემური მოდული, რომელიც უზრუნველყოფს უსაფრთხო და საიმედო Over-the-Air (OTA) firmware განახლებას.
  - **Service API:** ამატებს `FMW_SERVICE_TYPE_OTA_API` სერვისს, რომელიც სხვა მოდულებს საშუალებას აძლევს, დაიწყონ განახლების პროცესი URL-ის მითითებით.
  - **სისტემური ინტეგრაცია:** განახლების დაწყებამდე, `Health Monitor`-ის მეშვეობით ამოწმებს სისტემის რესურსებს (თავისუფალი მეხსიერება).
  - **ვიზუალური უკუკავშირი:** `RGB LED Indicator`-ის გამოყენებით, მომხმარებელს აწვდის ვიზუალურ ინფორმაციას განახლების პროცესის სტატუსის შესახებ (დაწყება, წარმატება, შეცდომა).
  - **ივენთებზე დაფუძნებული მუშაობა:** აქვეყნებს `OTA_STARTED`, `OTA_SUCCESS`, `OTA_FAILED` ივენთებს, რაც სხვა მოდულებს საშუალებას აძლევს, რეაგირება მოახდინონ განახლების პროცესის სხვადასხვა ეტაპზე.
  - **უსაფრთხოება:** მხარს უჭერს განახლებას HTTPS-ით და იყენებს ESP-IDF-ის ჩაშენებულ სერტიფიკატების ნაკრებს.

### 🏗️ ინფრასტრუქტურა

- **დაემატა საჯარო ინტერფეისები:** შეიქმნა `health_interface.h` და `rgb_led_interface.h` ფაილები `components/interfaces` დირექტორიაში, რაც უზრუნველყოფს შესაბამისი მოდულების API-ების იზოლირებულ და სტანდარტულ გამოყენებას Service Locator-ის მეშვეობით.

## [v2.2.0] - 2025-07-01

### ✨ ახალი ფუნქციონალი

- **დაემატა Health Monitor მოდული:** შეიქმნა ახალი სისტემური მოდული, რომელიც უზრუნველყოფს სისტემის ჯანმრთელობის მონიტორინგს.
  - **მეხსიერების კონტროლი:** პერიოდულად ამოწმებს თავისუფალი ოპერატიული მეხსიერების (Heap) რაოდენობას და აგენერირებს `SYSTEM_HEALTH_ALERT` ივენთს, თუ ის დაეცემა კონფიგურაციით განსაზღვრულ ზღვარზე დაბლა.
  - **ტასკების სტეკის მონიტორინგი:** ამოწმებს ყველა აქტიური ტასკის სტეკის გამოყენების მაჩვენებელს (High Water Mark) და აგენერირებს alert-ს კრიტიკული ზღვარის გადაცდომისას.
  - **დიაგნოსტიკური API:** ამატებს `FMW_SERVICE_TYPE_HEALTH_API` სერვისს, რომელიც სხვა მოდულებს საშუალებას აძლევს, მოითხოვონ სისტემის ჯანმრთელობის სრული რეპორტი JSON ფორმატში.
  - **გაფართოებადი არქიტექტურა:** გააჩნია მექანიზმი, რომლითაც სხვა მოდულებს შეუძლიათ დაარეგისტრირონ საკუთარი, აპლიკაციისთვის სპეციფიკური შემოწმების ფუნქციები.

### 🐛 შეცდომების გასწორება

- **გასწორდა FreeRTOS სტატისტიკის ფუნქციების ლინკირების პრობლემა:** მოგვარდა `undefined reference to uxTaskGetSystemState` შეცდომა `menuconfig`-ში `CONFIG_FREERTOS_USE_TRACE_FACILITY`-ის ჩართვით და კოდის შესაბამისი მოდიფიკაციით, ESP-IDF v5.4.1-ის სპეციფიკის გათვალისწინებით.

## [v2.1.1] - 2025-07-01

### 🐛 შეცდომების გასწორება

- **გასწორდა NVS-დან მონაცემების წაკითხვის შეცდომა:** მოგვარდა კრიტიკული შეცდომა `wifi_manager`-ში, რომლის დროსაც WiFi-ს მონაცემები არასწორად იკითხებოდა NVS მეხსიერებიდან მოწყობილობის გადატვირთვის შემდეგ. პრობლემა გამოწვეული იყო მეხსიერების არასწორი მართვით. `load_credentials_from_nvs` ფუნქცია გადაკეთდა უფრო მტკიცე, დაცვით მექანიზმზე, რომელიც იყენებს დროებით ბუფერებს და `memcpy`-ს მონაცემთა მთლიანობის უზრუნველსაყოფად.
- **გაუმჯობესდა Reconnect-Provisioning ციკლი:** `ble_provisioning` მოდული ახლა კორექტულად ამუშავებს `PROV_START_REQUESTED` ივენთს, რაც საშუალებას აძლევს მას, ხელახლა დაიწყოს provisioning პროცესი WiFi-სთან დაკავშირების მრავალჯერადი წარუმატებელი მცდელობის შემდეგ. ამით სრულდება აღდგენის სრული და გამართული ციკლი.

### ✨ ახალი ფუნქციონალი

- **დაკავშირების მცდელობების ლიმიტი და Provisioning-ზე გადასვლა:** `wifi_manager`-ს დაემატა დაკავშირების მცდელობების კონფიგურირებადი ლიმიტი (`CONFIG_WIFI_MANAGER_MAX_RECONNECT_ATTEMPTS`). ლიმიტის ამოწურვის შემდეგ, მოდული ავტომატურად შლის არასწორ მონაცემებს NVS-დან და ითხოვს provisioning პროცესის დაწყებას, რაც მომხმარებელს საშუალებას აძლევს, მარტივად განაახლოს WiFi-ს პარამეტრები.

---

## [v2.1.0] - 2025-06-30

### ✨ ახალი ფუნქციონალი

- **მოდულების ინიციალიზაციის პრიორიტეტიზაცია:** დაინერგა მოდულების დალაგების მტკიცე მექანიზმი `init_level` პარამეტრის საფუძველზე. `Module Registry` ახლა ავტომატურად ალაგებს ყველა რეგისტრირებულ მოდულს მათი `init_level`-ის მიხედვით ინიციალიზაციამდე, რაც უზრუნველყოფს, რომ დაბალი `init_level`-ის მქონე (მაღალი პრიორიტეტის) მოდულები პირველები გაეშვან. ეს ხსნის დამოკიდებულებას `system_config.json`-ში მოდულების თანმიმდევრობაზე.
- **RGB LED ინდიკატორის გაუმჯობესება:** `rgb_led_indicator` მოდულს დაემატა `PULSE` (პულსაციის) ეფექტის მხარდაჭერა. ივენთების დამუშავება ახლა ხდება ცხრილზე დაფუძნებული მიდგომით, რაც კოდს უფრო მასშტაბირებადს და წაკითხვადს ხდის. `release_control` API ახლა კორექტულად აღადგენს სისტემის ბოლო ცნობილ მდგომარეობას.

### 🐛 შეცდომების გასწორება

- **გასწორდა Race Condition მოდულების ინიციალიზაციისას:** მოგვარდა კრიტიკული დროის ფაქტორით გამოწვეული პრობლემა, როდესაც მოდულები (მაგ., `rgb_led_indicator`) აცდენდნენ სისტემის ადრეულ ივენთებს (მაგ., `WIFI_CREDENTIALS_NOT_FOUND`), რადგან მათი ინიციალიზაცია ხდებოდა ივენთის გამომქვეყნებელი მოდულის შემდეგ. `init_level`-ზე დაფუძნებული დალაგება უზრუნველყოფს ინიციალიზაციის სწორ თანმიმდევრობას.
- **გასწორდა LEDC დრაივერის გამოყენება:** `rgb_led_indicator` მოდულის კოდი შეიცვალა ისე, რომ LEDC არხების ინიციალიზაცია ხდება მხოლოდ ერთხელ, `init` ფუნქციაში. ამან აღმოფხვრა `GPIO is not usable, maybe conflict with others` გაფრთხილება და უზრუნველყო LED ეფექტების გლუვი, უწყვეტი მუშაობა.
- **გასწორდა `qsort`-ის შედარების ფუნქციის ლოგიკა:** გასწორდა მაჩვენებლების ტიპების კონვერტაცია `compare_modules_by_init_level` ფუნქციაში, მოდულების მასივის სწორად დალაგების უზრუნველსაყოფად.

### ♻️ რეფაქტორინგი

- **`init_level`-ის მართვის ცენტრალიზაცია:** `init_level`-ის დაყენების პასუხისმგებლობა ახლა დელეგირებულია თითოეული მოდულის `_create` ფუნქციაზე, რომელიც კითხულობს მნიშვნელობას შესაბამისი `module.json`-იდან (გაერთიანებული `config` ობიექტის მეშვეობით). ეს მოდულის პრიორიტეტს ხდის თვითკმარს და დამოუკიდებელს `system_config.json`-ისგან.
- **გაუმჯობესდა ივენთების დამუშავება `rgb_led_indicator`-ში:** `if-else` ბრძანებების ჯაჭვი ჩანაცვლდა `static event_map` ცხრილით, რაც უზრუნველყოფს "ივენთი-ბრძანება" კავშირების უფრო სუფთა და ადვილად მართვად იმპლემენტაციას.
