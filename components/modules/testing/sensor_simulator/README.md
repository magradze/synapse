# 🧪 მოდული: `sensor_simulator`

**🗂️ კატეგორია:** `testing`  
**✒️ ავტორი:** Synapse Framework Team  
**🔖 ვერსია:** 1.0.0

## 1. 📜 მიმოხილვა

`sensor_simulator` არის **სატესტო და დეველოპმენტის დამხმარე მოდული**. მისი ერთადერთი დანიშნულებაა, მოახდინოს სხვადასხვა ტიპის სენსორების ქცევის იმიტაცია ფიზიკური აპარატურის გარეშე.

ის იყენებს `System Timer Service`-ს, რათა პერიოდულად გამოაქვეყნოს წინასწარ განსაზღვრული სენსორული ივენთები შემთხვევითი, მაგრამ რეალისტური მნიშვნელობებით. ეს მოდული ფასდაუდებელია ისეთი კომპონენტების შესამოწმებლად, როგორიცაა `sensor_aggregator`, `alarms_manager` ან `mqtt_manager`, რადგან ის უზრუნველყოფს კონტროლირებად და განმეორებად მონაცემთა ნაკადს.

## 2. 🏛️ არქიტექტურული პრინციპები

- **Event-driven:** მოდული არის სუფთა "ივენთების მწარმოებელი". ის იყენებს ტაიმერს, რათა პერიოდულად გამოაქვეყნოს ივენთები.
- **მარტივი და მსუბუქი:** არ გააჩნია რთული ლოგიკა ან დამოკიდებულებები, გარდა `System Timer Service`-ისა.
- **არაკონფიგურირებადი:** ამ ეტაპზე, მოდულის ქცევა (გამოსაქვეყნებელი ივენთების სია, ინტერვალი) `hardcoded`-ია კოდში, რადგან მისი მთავარი მიზანი ტესტირებაა.

## 3. ⚙️ კონფიგურაცია

მოდულის ჩასართავად, დაამატეთ შემდეგი ობიექტი `system_config.json`-ში:

```json
{
    "type": "sensor_simulator",
    "enabled": true,
    "config": {
        "instance_name": "main_sensor_sim"
    }
}
```

## 4. 📢 გამოქვეყნებული ივენთები

ამჟამინდელი იმპლემენტაცია ყოველ 15 წამში აქვეყნებს შემდეგ სამ ივენთს:

| ივენთის სახელი | Payload-ის მაგალითი |
| :--- | :--- |
| `SENSOR_DATA_TEMPERATURE` | `{"value":23.5}` |
| `SENSOR_DATA_HUMIDITY` | `{"value":55.2}` |
| `SENSOR_DATA_LIGHT` | `{"value":350}` |

## 5. 💡 გამოყენების მაგალითი

`sensor_simulator`-ის მთავარი გამოყენების სცენარი არის `sensor_aggregator`-ის ტესტირება.

1. ჩართეთ `sensor_simulator` და `sensor_aggregator` მოდულები `system_config.json`-ში.
2. დააკონფიგურირეთ `sensor_aggregator`, რომ მოუსმინოს ზემოთ ჩამოთვლილ სამ ივენთს.
3. დააკვირდით ლოგებს. თქვენ უნდა დაინახოთ, როგორ აქვეყნებს სიმულატორი მონაცემებს და როგორ რეაგირებს მასზე აგრეგატორი.

ეს მოდული არ არის განკუთვნილი production build-ებისთვის და რეკომენდებულია მისი გამორთვა (`"enabled": false`) საბოლოო firmware-ში.