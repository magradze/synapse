# Synapse ESP Framework — არქიტექტურის მიმოხილვა

## მიზანი

Synapse ESP Framework-ის არქიტექტურა შექმნილია იმისთვის, რომ უზრუნველყოს მოდულური, გაფართოებადი და სტანდარტიზებული ჩაშენებული სისტემების (embedded systems) განვითარება ESP-IDF ეკოსისტემაში. მთავარი პრინციპებია მოდულურობა, იზოლაცია, ავტომატიზაცია და მაღალი ხარისხის კოდის უზრუნველყოფა.

## ძირითადი არქიტექტურული პრინციპები

- **მოდულურობა:** ყველა ფუნქციონალი წარმოდგენილია დამოუკიდებელი მოდულების სახით, რომლებიც შეიძლება ჩაერთოს ან გამოირთოს კონფიგურაციით.
- **იზოლაცია:** მოდულებს შორის პირდაპირი დამოკიდებულებები აკრძალულია. კომუნიკაცია ხდება მხოლოდ `Service Locator`-ის ან `Event Bus`-ის მეშვეობით.
- **სტანდარტიზაცია:** ყველა მოდული და ინფრასტრუქტურა მიჰყვება ერთიან naming, structure და communication სტანდარტებს.
- **გაფართოებადობა:** ახალი მოდულის დამატება შესაძლებელია მინიმალური ძალისხმევით.
- **ავტომატიზაცია:** მოდულების აღმოჩენა, build-სისტემაში ინტეგრაცია და `Module Factory`-ის გენერაცია სრულად ავტომატიზირებულია CMake სკრიპტების გამოყენებით.
- **დოკუმენტირებულობა:** ყველა არქიტექტურული გადაწყვეტილება და სტანდარტი აღწერილია შესაბამის დოკუმენტებში.

## არქიტექტურული ფენები და ძირითადი კომპონენტები

1. **Core (ბირთვი):**
    - `Service Locator` — მოდულებს შორის API-ს მოძიება და გამოძახება იზოლაციის დაცვით.
    - `Event Bus` — broadcast/notification ტიპის კომუნიკაცია მოდულებს შორის.
    - `Module Registry` — მოდულების რეგისტრაცია, ინიციალიზაცია და მართვა.
    - `Module Factory` — მოდულების დინამიური შექმნა კონფიგურაციიდან.
    - `Configuration Manager` — სისტემის და მოდულების კონფიგურაციის მართვა.
    - `Logging` — სტანდარტიზებული ლოგირება.

2. **Interfaces:**
    - გლობალური ინტერფეისები, რომლებიც უზრუნველყოფს მოდულებს შორის "კონტრაქტებს".

3. **Modules:**
    - კატეგორიებად დაყოფილი ფუნქციონალური გაფართოებები (სენსორები, აქტუატორები, კომუნიკაციები, ეკრანები, დრაივერები, სისტემური და დამხმარე მოდულები).

4. **Configuration:**
    - **(განახლებულია)** მოქნილი და **დეცენტრალიზებული** კონფიგურაციის სისტემა, რომელიც ეფუძნება `Kconfig`-ს, ბაზისურ `system_config.json`-ს და თითოეული მოდულის საკუთარ `config.json` ფაილს.

## მოდულებს შორის კომუნიკაციის პატერნები

- **Service Locator Pattern:** გამოიყენება კონკრეტული API-ს მისაღებად და პირდაპირი ფუნქციური გამოძახებისთვის. უზრუნველყოფს მოდულებს შორის მინიმალურ დამოკიდებულებას.
- **Event Bus Pattern:** გამოიყენება broadcast/notification სცენარებისთვის, როცა ერთზე მეტ მოდულს სჭირდება ერთი მოვლენის მიღება.
- **აკრძალულია:** პირდაპირი დამოკიდებულება მოდულებს შორის და სხვა მოდულის header-ის პირდაპირი ჩასმა (`#include`).

## სიცოცხლის ციკლი

- **Create:** მოდულის ობიექტის შექმნა და კონფიგურაციის გადაცემა.
- **Init:** hardware-ის ან სხვა რესურსების ინიციალიზაცია.
- **Start:** მოდულის აქტიური მუშაობის დაწყება (მაგ., ტასკის გაშვება).
- **Deinit:** ყველა გამოყოფილი რესურსის გათავისუფლება.

## საქაღალდეებისა და ფაილების სტრუქტურა

- **main/** — მთავარი აპლიკაცია (`app_main` და ძირითადი ლოგიკა).
- **components/core/** — ბირთვი: `Service Locator`, `Event Bus`, `Module Registry` და სხვა.
- **components/interfaces/** — გლობალური ინტერფეისები.
- **components/modules/** — კატეგორიებად დაყოფილი მოდულები.
- **configs/** — ბაზისური `system_config.json` ფაილი.
- **docs/** — დოკუმენტაცია და სტანდარტები.

## არქიტექტურული დიაგრამა (მოკლე)

```plaintext
┌──────────────┐      Service Locator     ┌──────────────┐
│   Module A   │ ───────────────────────► │   Module B   │
└──────────────┘      (Direct Call)       └──────────────┘
        │
        │ Event Bus
        │ (Broadcast)
        ▼
┌──────────────┐
│   Module C   │
└──────────────┘
```

## სტანდარტები და დოკუმენტაცია

ყველა naming, structure, communication და სხვა წესები აღწერილია შესაბამის convention დოკუმენტებში:

- variable_naming.md
- function_naming.md
- module_structure.md
- configuration_management.md
- communication_patterns.md
- error_handling.md
- logging_standards.md
- coding_doxygen_standard.md

## დასკვნა

Synapse ESP Framework-ის არქიტექტურა უზრუნველყოფს მოქნილ, სტანდარტიზებულ და გაფართოებად ჩაშენებულ სისტემებს, სადაც თითოეული მოდული დამოუკიდებელია, ადვილად ტესტირებადი და დოკუმენტირებულია. ყველა გადაწყვეტილება და სტანდარტი დეტალურადაა აღწერილი დოკუმენტაციაში, რაც ამარტივებს როგორც ახალ, ისე გამოცდილ დეველოპერებს ჩართვას და განვითარებას.
