# გაფართოებადობისა და მოდულარობის არქიტექტურული გადაწყვეტილებები (Extensibility & Modularity)

---

## მიზანი

ეს დოკუმენტი აღწერს Synapse ESP Framework-ში გაფართოებადობისა და მოდულარობის არქიტექტურულ გადაწყვეტილებებს, არჩეულ სტრატეგიებს, მოტივაციას, ალტერნატივებს და საბოლოო გადაწყვეტილების შედეგებს naming/structure კონვენციების დაცვით.

---

## კონტექსტი

ფრეიმვორქის მთავარი ღირებულებაა მარტივად გაფართოებადი და მოდულური არქიტექტურა, რომელიც საშუალებას აძლევს დეველოპერებს დაამატონ ან შეცვალონ ფუნქციონალი ძირითადი სისტემის ცვლილების გარეშე. აუცილებელია მკაფიო სტანდარტები და სტრუქტურა, რათა უზრუნველყოფილი იყოს კოდის ერთგვაროვნება და მარტივი მხარდაჭერა.

---

## არჩეული სტრატეგიები

- **მოდულური არქიტექტურა:** ყველა ფუნქციონალი წარმოდგენილია დამოუკიდებელი მოდულების სახით
- **სტანდარტული საქაღალდეებისა და ფაილების სტრუქტურა:** თითოეულ მოდულს აქვს საკუთარი საქაღალდე, header/source ფაილები, README და კონფიგურაცია
- **Public API-ების გამოყენება:** მოდულებს შორის ურთიერთქმედება ხდება მხოლოდ public API-ების მეშვეობით
- **Service Locator და Event Bus:** კომუნიკაციისთვის გამოიყენება მხოლოდ ეს პატერნები
- **კონვენციების დაცვა:** ყველა მოდული მიჰყვება naming, structure და documentation სტანდარტებს

---

## არგუმენტები და მოტივაცია

- მოდულური არქიტექტურა ამარტივებს ახალი ფუნქციონალის დამატებას და ტესტირებას
- სტანდარტული სტრუქტურა ამცირებს შეცდომების ალბათობას და ამარტივებს მხარდაჭერას
- Public API-ები უზრუნველყოფს მოდულების იზოლაციას
- Service Locator/Event Bus ამცირებს დამოკიდებულებებს და ზრდის მოქნილობას
- ალტერნატივა (მონოლითური კოდი, პირდაპირი დამოკიდებულებები) უარყოფილია გაფართოებადობისა და ტესტირებადობის არქონის გამო

---

## შედეგები და გავლენა

- ახალი მოდულის დამატება ან არსებული მოდულის გაფართოება შესაძლებელია მინიმალური ძალისხმევით
- სისტემის მხარდაჭერა და ტესტირება მარტივდება
- კოდის ერთგვაროვნება და სტანდარტიზაცია უზრუნველყოფილია
- მოდულების დამოუკიდებლობა ზრდის სისტემის სტაბილურობას

---

## გამოყენების მაგალითები

### ახალი მოდულის დამატება
```
components/modules/sensors/new_sensor_module/
├── CMakeLists.txt
├── module.json
├── README.md
├── include/
│   └── new_sensor_module.h
├── src/
│   └── new_sensor_module.c
```

### Public API-ის გამოყენება
```c
module_t *new_sensor_module_create(const cJSON *config);
esp_err_t new_sensor_module_api_enable(void);
```

---

## აკრძალული და რეკომენდებული პრაქტიკები

❌ **არასდროს:**
- პირდაპირი დამოკიდებულება სხვა მოდულზე
- არასტანდარტული სტრუქტურა ან სახელები
- დოკუმენტაციის გარეშე ახალი ფუნქციონალის დამატება

✅ **ყოველთვის:**
- დაიცავით ყველა naming, structure და documentation კონვენცია
- გამოიყენეთ მხოლოდ public API-ები მოდულებს შორის
- ჩაატარეთ ტესტირება და აღწერეთ ცვლილებები დოკუმენტაციაში

---

## დაკავშირებული დოკუმენტები

- [core_components.md](core_components.md)
- [module_structure.md](../convention/module_structure.md)
- [architecture_overview.md](architecture_overview.md)
- [faq.md](../structure/faq.md)

---

_დამატებითი კითხვებისთვის იხილეთ შესაბამისი დოკუმენტაცია ან მიმართეთ გუნდის დოკუმენტაციის პასუხისმგებელ პირს._

