<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Synapse ESP Framework: 🚌 მოდული: &lt;tt&gt;spi_bus&lt;/tt&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Synapse ESP Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_components_2modules_2drivers_2spi__bus_2README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">🚌 მოდული: &lt;tt&gt;spi_bus&lt;/tt&gt;</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md87"></a> <b>🗂️ კატეგორია:</b> <code>drivers</code> <br  />
 <b>✒️ ავტორი:</b> Synapse Framework Team <br  />
 <b>🔖 ვერსია:</b> 1.1.0</p>
<h1><a class="anchor" id="autotoc_md88"></a>
1. 📜 მიმოხილვა</h1>
<p><code>spi_bus</code> არის Synapse Framework-ის <b>ფუნდამენტური აპარატურული დრაივერის მოდული</b>. ის უზრუნველყოფს ცენტრალიზებულ, უსაფრთხო და ნაკად-დაცულ (thread-safe) ინტერფეისს ESP32-ის SPI (Serial Peripheral Interface) პერიფერიასთან სამუშაოდ.</p>
<p>მისი მთავარი მიზანია, მოახდინოს SPI ავტობუსის, როგორც <b>გაზიარებული რესურსის</b>, მართვის აბსტრაგირება. იმის ნაცვლად, რომ თითოეულმა SPI მოწყობილობამ (მაგ., ეკრანი, SD ბარათი, shift register) თავად მოახდინოს SPI დრაივერის ინიციალიზაცია, ისინი ითხოვენ წვდომას ამ ცენტრალიზებული სერვისისგან. ეს გამორიცხავს კონფლიქტებს, ამარტივებს კოდს და უზრუნველყოფს სისტემის სტაბილურობას.</p>
<h1><a class="anchor" id="autotoc_md89"></a>
2. 🏛️ არქიტექტურული პრინციპები</h1>
<ul>
<li><b>სერვისის მომწოდებელი (Pure Service Provider):</b> ⚙️ მოდული არის სუფთა "სერვისის მომწოდებელი". ის არეგისტრირებს <code><a class="el" href="structspi__bus__api__t.html" title="The public Service API structure for the SPI Bus module.">spi_bus_api_t</a></code> სერვისს <code>Service Locator</code>-ში და არ არის დამოკიდებული სხვა აპლიკაციის დონის მოდულებზე.</li>
<li><b>რესურსების უსაფრთხოება (Resource Safety):</b> 🛡️ <code>init</code> ფაზაში, მოდული იყენებს <code>Resource Manager</code>-ს, რათა ექსკლუზიურად დაიკავოს (დალოქოს) როგორც SPI ჰოსტი, ისე კონფიგურაციაში მითითებული MISO, MOSI და SCLK GPIO პინები. ეს გარანტიას იძლევა, რომ სხვა მოდული შემთხვევით ვერ გამოიყენებს ამ რესურსებს.</li>
<li><b>ნაკად-უსაფრთხოება (Thread-Safety):</b> 🔒 თითოეული SPI ოპერაცია (<code>add_device</code>, <code>remove_device</code>, <code>transmit</code>) დაცულია <code>Mutex</code>-ით. ეს უზრუნველყოფს, რომ მრავალტასკიან გარემოშიც კი, SPI ავტობუსზე ერთდროულად მხოლოდ ერთი მოწყობილობის დამატება/მოშორება ან ტრანზაქცია შესრულდება.</li>
<li><b>მოწყობილობების მართვა:</b> 🚌 მოდული მართავს ერთ SPI ავტობუსზე მიერთებულ მრავალ მოწყობილობას. თითოეული მოწყობილობა ემატება საკუთარი კონფიგურაციით (<code>spi_device_interface_config_t</code>) და იღებს უნიკალურ <code>handle</code>-ს, რომელიც გამოიყენება მასთან კომუნიკაციისთვის.</li>
<li><b>ადრეული ინიციალიზაცია (Early Initialization):</b> 📉 <code>init_level: 10</code> უზრუნველყოფს, რომ SPI ავტობუსი ინიციალიზდება სისტემის გაშვების ძალიან ადრეულ ეტაპზე, რათა ის ხელმისაწვდომი იყოს ყველა მასზე დამოკიდებული მოდულისთვის.</li>
</ul>
<h1><a class="anchor" id="autotoc_md90"></a>
3. ⚙️ კონფიგურაცია (&lt;tt&gt;config.json&lt;/tt&gt;)</h1>
<p>მოდულის კონფიგურაცია ხდება მისი <code>config.json</code> ფაილის საშუალებით. შესაძლებელია სისტემაში რამდენიმე, სხვადასხვა SPI ავტობუსის ერთდროულად კონფიგურირება.</p>
<p><b>კონფიგურაციის მაგალითი:</b></p>
<div class="fragment"><div class="line">[</div>
<div class="line">  {</div>
<div class="line">    &quot;type&quot;: &quot;spi_bus&quot;,</div>
<div class="line">    &quot;enabled&quot;: true,</div>
<div class="line">    &quot;config&quot;: {</div>
<div class="line">      &quot;instance_name&quot;: &quot;main_spi_bus&quot;,</div>
<div class="line">      &quot;spi_host&quot;: 2,</div>
<div class="line">      &quot;miso_pin&quot;: 12,</div>
<div class="line">      &quot;mosi_pin&quot;: 13,</div>
<div class="line">      &quot;sclk_pin&quot;: 14,</div>
<div class="line">      &quot;dma_chan&quot;: 1</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">]</div>
</div><!-- fragment --><p><b>კონფიგურაციის პარამეტრები:</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">პარამეტრი   </th><th class="markdownTableHeadLeft">ტიპი   </th><th class="markdownTableHeadLeft">აღწერა   </th><th class="markdownTableHeadCenter">სავალდებულო    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>instance_name</code>   </td><td class="markdownTableBodyLeft">სტრიქონი   </td><td class="markdownTableBodyLeft">SPI ავტობუსის უნიკალური სახელი. ამ სახელით ხდება სერვისის რეგისტრაცია.   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>spi_host</code>   </td><td class="markdownTableBodyLeft">რიცხვი   </td><td class="markdownTableBodyLeft">გამოსაყენებელი SPI ჰოსტის ID. ESP32-სთვის, როგორც წესი, <code>1</code> (VSPI) ან <code>2</code> (HSPI).   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>miso_pin</code>   </td><td class="markdownTableBodyLeft">რიცხვი   </td><td class="markdownTableBodyLeft">MISO ხაზისთვის განკუთვნილი GPIO პინის ნომერი.   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>mosi_pin</code>   </td><td class="markdownTableBodyLeft">რიცხვი   </td><td class="markdownTableBodyLeft">MOSI ხაზისთვის განკუთვნილი GPIO პინის ნომერი.   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>sclk_pin</code>   </td><td class="markdownTableBodyLeft">რიცხვი   </td><td class="markdownTableBodyLeft">SCLK (საათის) ხაზისთვის განკუთვნილი GPIO პინის ნომერი.   </td><td class="markdownTableBodyCenter">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>dma_chan</code>   </td><td class="markdownTableBodyLeft">რიცხვი   </td><td class="markdownTableBodyLeft">გამოსაყენებელი DMA არხი. <code>0</code> ნიშნავს DMA-ს გარეშე.   </td><td class="markdownTableBodyCenter">✅   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md91"></a>
4. 🔌 Service API (&lt;tt&gt;spi_bus_api_t&lt;/tt&gt;)</h1>
<p>სხვა მოდულებს შეუძლიათ მიიღონ წვდომა ამ სერვისზე <code>Service Locator</code>-ის მეშვეობით. სერვისის ტიპი: **<code>FMW_SERVICE_TYPE_SPI_BUS_API</code>**.</p>
<p><b>API ფუნქციები:</b></p>
<ul>
<li>**<code>esp_err_t add_device(context, dev_config, out_handle);</code>** <br  />
 ➕ ამატებს ახალ მოწყობილობას SPI ავტობუსზე. <code>dev_config</code> განსაზღვრავს მოწყობილობის პარამეტრებს (სიჩქარე, CS პინი და ა.შ.). წარმატების შემთხვევაში, <code>out_handle</code>-ში წერს მოწყობილობის უნიკალურ handle-ს.</li>
<li>**<code>esp_err_t remove_device(context, handle);</code>** <br  />
 ➖ შლის მოწყობილობას ავტობუსიდან.</li>
<li>**<code>esp_err_t transmit(context, handle, transaction);</code>** <br  />
 🔄 ასრულებს სრულ SPI ტრანზაქციას მითითებულ მოწყობილობასთან.</li>
</ul>
<h1><a class="anchor" id="autotoc_md92"></a>
5. 💡 გამოყენების მაგალითი</h1>
<p><code>sn74hc595n_writer</code> მოდული იყენებს <code>spi_bus</code> სერვისს.</p>
<p>**<code><a class="el" href="sn74hc595n__writer_8c.html" title="Implementation of the SN74HC595N shift register driver module.">sn74hc595n_writer.c</a></code>-ში, <code>init</code> ფუნქციაში:**</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="service__locator_8h.html">service_locator.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="spi__bus__interface_8h.html">spi_bus_interface.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> esp_err_t sn74hc595n_writer_init(<a class="code hl_struct" href="structmodule__t.html">module_t</a> *self) {</div>
<div class="line">    <a class="code hl_struct" href="structsn74hc595n__private__data__t.html">sn74hc595n_private_data_t</a> *private_data = (<a class="code hl_struct" href="structsn74hc595n__private__data__t.html">sn74hc595n_private_data_t</a> *)self-&gt;<a class="code hl_variable" href="structmodule__t.html#a2e4e556e94d9d5402250b0524a7c0196">private_data</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1. 🤝 ვიღებთ SPI სერვისის handle-ს Service Locator-იდან</span></div>
<div class="line">    private_data-&gt;spi_bus_handle = (<a class="code hl_struct" href="structspi__bus__handle__t.html">spi_bus_handle_t</a>*)<a class="code hl_function" href="service__locator_8h.html#aa1b2b027ce8a0dfecde7324ecf6e63bc">fmw_service_get</a>(private_data-&gt;spi_bus_service_name);</div>
<div class="line">    <span class="keywordflow">if</span> (!private_data-&gt;spi_bus_handle) {</div>
<div class="line">        ESP_LOGE(TAG, <span class="stringliteral">&quot;SPI bus service &#39;%s&#39; not found!&quot;</span>, private_data-&gt;spi_bus_service_name);</div>
<div class="line">        <span class="keywordflow">return</span> ESP_ERR_NOT_FOUND;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. ✍️ ვამატებთ ჩვენს shift register-ს, როგორც მოწყობილობას SPI ავტობუსზე</span></div>
<div class="line">    spi_device_interface_config_t dev_cfg = {</div>
<div class="line">        .mode = 0,</div>
<div class="line">        .clock_speed_hz = 10 * 1000 * 1000, <span class="comment">// 10 MHz</span></div>
<div class="line">        .spics_io_num = -1, <span class="comment">// CS პინს ვმართავთ ხელით (latch_pin)</span></div>
<div class="line">        .queue_size = 1,</div>
<div class="line">    };</div>
<div class="line">    esp_err_t ret = private_data-&gt;spi_bus_handle-&gt;api-&gt;add_device(</div>
<div class="line">        private_data-&gt;spi_bus_handle-&gt;context, </div>
<div class="line">        &amp;dev_cfg, </div>
<div class="line">        &amp;private_data-&gt;spi_device_handle</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">if</span> (ret != ESP_OK) {</div>
<div class="line">        ESP_LOGE(TAG, <span class="stringliteral">&quot;Failed to add SPI device: %s&quot;</span>, esp_err_to_name(ret));</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... (დანარჩენი ინიციალიზაციის ლოგიკა) ...</span></div>
<div class="line">    <span class="keywordflow">return</span> ESP_OK;</div>
<div class="line">}</div>
<div class="ttc" id="aservice__locator_8h_html"><div class="ttname"><a href="service__locator_8h.html">service_locator.h</a></div><div class="ttdoc">Framework-ის სერვის ლოკატორის საჯარო API.</div></div>
<div class="ttc" id="aservice__locator_8h_html_aa1b2b027ce8a0dfecde7324ecf6e63bc"><div class="ttname"><a href="service__locator_8h.html#aa1b2b027ce8a0dfecde7324ecf6e63bc">fmw_service_get</a></div><div class="ttdeci">service_handle_t fmw_service_get(const char *service_name)</div><div class="ttdoc">აბრუნებს რეგისტრირებულ სერვისს სახელით</div><div class="ttdef"><b>Definition</b> service_locator.c:179</div></div>
<div class="ttc" id="aspi__bus__interface_8h_html"><div class="ttname"><a href="spi__bus__interface_8h.html">spi_bus_interface.h</a></div><div class="ttdoc">Public Service API contract for the SPI Bus module.</div></div>
<div class="ttc" id="astructmodule__t_html"><div class="ttname"><a href="structmodule__t.html">module_t</a></div><div class="ttdoc">მოდულის ძირითადი სტრუქტურა, რომელიც განსაზღვრავს ფრეიმვორქის მოდულის კონტრაქტს.</div><div class="ttdef"><b>Definition</b> base_module.h:133</div></div>
<div class="ttc" id="astructmodule__t_html_a2e4e556e94d9d5402250b0524a7c0196"><div class="ttname"><a href="structmodule__t.html#a2e4e556e94d9d5402250b0524a7c0196">module_t::private_data</a></div><div class="ttdeci">void * private_data</div><div class="ttdoc">მაჩვენებელი მოდულის შიდა მონაცემებზე.</div><div class="ttdef"><b>Definition</b> base_module.h:157</div></div>
<div class="ttc" id="astructsn74hc595n__private__data__t_html"><div class="ttname"><a href="structsn74hc595n__private__data__t.html">sn74hc595n_private_data_t</a></div><div class="ttdef"><b>Definition</b> sn74hc595n_writer.c:20</div></div>
<div class="ttc" id="astructspi__bus__handle__t_html"><div class="ttname"><a href="structspi__bus__handle__t.html">spi_bus_handle_t</a></div><div class="ttdoc">The handle returned by the Service Locator for an SPI bus service.</div><div class="ttdef"><b>Definition</b> spi_bus_interface.h:58</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md93"></a>
6. ❗ მნიშვნელოვანი შენიშვნები</h1>
<ul>
<li><b>დამოკიდებულება <code>CMakeLists.txt</code>-ში:</b> ნებისმიერმა მოდულმა, რომელიც იყენებს <code>spi_bus</code>-ის სერვისს, თავის <code>CMakeLists.txt</code> ფაილში, <code>REQUIRES</code> სექციაში უნდა დაამატოს <code>interfaces</code> (და არა <code>spi_bus</code>), რათა მიიღოს წვდომა <code><a class="el" href="spi__bus__interface_8h.html" title="Public Service API contract for the SPI Bus module.">spi_bus_interface.h</a></code>-ზე.</li>
<li><b>CS პინის მართვა:</b> ბევრი მოწყობილობა მოითხოვს Chip Select (CS) პინის ხელით მართვას. ამ შემთხვევაში, <code>spi_device_interface_config_t</code>-ში <code>spics_io_num</code> უნდა იყოს <code>-1</code>, და მომხმარებელმა მოდულმა თავად უნდა მართოს CS პინი ტრანზაქციამდე და მის შემდეგ. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
