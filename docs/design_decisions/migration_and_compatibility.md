# მიგრაციისა და თავსებადობის არქიტექტურული გადაწყვეტილებები (Migration & Compatibility)

---

## მიზანი

ეს დოკუმენტი აღწერს Synapse ESP Framework-ში მიგრაციისა და თავსებადობის არქიტექტურულ გადაწყვეტილებებს, არჩეულ სტრატეგიებს, მოტივაციას, ალტერნატივებს და საბოლოო გადაწყვეტილების შედეგებს naming/structure კონვენციების დაცვით.

---

## კონტექსტი

ფრეიმვორქის განვითარებასთან ერთად საჭიროა ძველი ვერსიებიდან ახალზე უსაფრთხო და პროგნოზირებადი მიგრაცია, ასევე სხვადასხვა მოდულისა და სისტემის თავსებადობის უზრუნველყოფა. აუცილებელია მინიმალური ცვლილებებით არსებული პროექტების განახლება და backwards compatibility-ის შენარჩუნება.

---

## არჩეული სტრატეგიები

- **სქემის ვერსიონირება:** ყველა კონფიგურაციის ფაილს (system_config.json, module.json) აქვს ვერსიის ველი (version)
- **Deprecated API-ების შენარჩუნება:** ძველი API-ები ინახება გარკვეული პერიოდის განმავლობაში, მაგრამ მონიშნულია როგორც deprecated
- **მიგრაციის სკრიპტები:** საჭიროების შემთხვევაში უზრუნველყოფილია ავტომატური მიგრაციის სკრიპტები (მაგ: config upgrade tools)
- **კონფიგურაციის ვალიდაცია:** ახალი ვერსიის ჩატვირთვისას ხდება კონფიგურაციის ვალიდაცია და საჭიროების შემთხვევაში fallback/default მნიშვნელობების გამოყენება
- **დოკუმენტირებული ცვლილებები:** ყველა breaking change და მიგრაციის ნაბიჯი აღწერილია დოკუმენტაციაში

---

## არგუმენტები და მოტივაცია

- სქემის ვერსიონირება ამარტივებს ძველი და ახალი კონფიგურაციების მართვას
- Deprecated API-ების შენარჩუნება ამცირებს მიგრაციის რისკებს
- მიგრაციის სკრიპტები ამარტივებს პროექტების ავტომატურ განახლებას
- დოკუმენტირებული ცვლილებები ზრდის დეველოპერების ნდობას და ამცირებს შეცდომების ალბათობას
- ალტერნატივა (breaking changes ყოველ ვერსიაზე) უარყოფილია backwards compatibility-ის არქონის გამო

---

## შედეგები და გავლენა

- შესაძლებელია ძველი პროექტების უსაფრთხო განახლება ახალ ვერსიაზე
- დეველოპერებს მარტივად შეუძლიათ მიგრაცია და ახალი ფუნქციონალის გამოყენება
- სისტემის სტაბილურობა და მომხმარებლის ნდობა იზრდება
- Deprecated API-ების შენარჩუნება ზრდის კოდის მოცულობას გარკვეული პერიოდის განმავლობაში

---

## გამოყენების მაგალითები

### სქემის ვერსიონირება
```json
{
    "firmware": {
        "version": "2.0.0",
        "description": "New config schema"
    },
    ...
}
```

### Deprecated API-ის მონიშვნა
```c
/**
 * @deprecated გამოიყენეთ new_sensor_module_api_enable()
 */
esp_err_t old_sensor_module_enable(void);
```

### მიგრაციის სკრიპტის გამოყენება
```sh
python tools/migrate_config.py --from 1.0.0 --to 2.0.0 system_config.json
```

---

## აკრძალული და რეკომენდებული პრაქტიკები

❌ **არასდროს:**
- breaking changes დოკუმენტაციის და მიგრაციის ინსტრუქციის გარეშე
- ძველი კონფიგურაციის ან API-ის დაუფიქრებელი წაშლა
- არასტანდარტული მიგრაციის პროცედურები

✅ **ყოველთვის:**
- გამოიყენეთ ვერსიონირება ყველა კონფიგურაციაში
- შეინარჩუნეთ deprecated API-ები განსაზღვრული პერიოდის განმავლობაში
- უზრუნველყავით მიგრაციის ინსტრუქციები და/ან სკრიპტები
- აღწერეთ ყველა ცვლილება და მიგრაციის ნაბიჯი დოკუმენტაციაში

---

## დაკავშირებული დოკუმენტები

- [core_components.md](core_components.md)
- [architecture_overview.md](architecture_overview.md)
- [configuration_management.md](../convention/configuration_management.md)
- [faq.md](../structure/faq.md)

---

_დამატებითი კითხვებისთვის იხილეთ შესაბამისი დოკუმენტაცია ან მიმართეთ გუნდის დოკუმენტაციის პასუხისმგებელ პირს._

