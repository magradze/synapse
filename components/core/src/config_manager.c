/**
 * @file config_manager.c
 * @brief Implementation of the Configuration Manager.
 * @author Giorgi Magradze & Synapse AI
 * @version 7.0.0 - Final Correct Implementation
 * @date 2025-07-01
 *
 * @details
 * This is the final, correct implementation that supports the decentralized
 * config.json model. It assembles the full configuration from multiple
 * embedded files on first boot and then uses a simple, single-key NVS
 * strategy for subsequent boots.
 */

#include "config_manager.h"
#include "logging.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include <string.h>
#include <stdlib.h>

// This header is auto-generated by collect_configs.cmake
#include "embedded_configs.h"

DEFINE_COMPONENT_TAG("CONFIG_MANAGER", SYNAPSE_LOG_COLOR_BLUE);

static const char *NVS_NAMESPACE = "synapse_cfg";
static const char *NVS_FULL_CONFIG_KEY = "full_config_v3"; // New key to invalidate old data

static cJSON *config_root_node = NULL;
static SemaphoreHandle_t config_mutex = NULL;

// --- Internal Function Prototypes ---
static esp_err_t load_config_from_nvs(void);
static esp_err_t load_config_from_defaults(void);
static esp_err_t save_config_to_nvs(void);
static const cJSON *find_module_config_by_name(const char *module_name);
static const cJSON *get_node_by_key(const char *key);

// =========================================================================
//                      Public API Implementation
// =========================================================================

esp_err_t synapse_config_manager_init(void)
{
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_LOGW(TAG, "NVS partition corrupted or version mismatch. Erasing...");
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    ESP_ERROR_CHECK(err);

    config_mutex = xSemaphoreCreateMutex();
    if (!config_mutex)
        return ESP_ERR_NO_MEM;

    if (load_config_from_nvs() != ESP_OK)
    {
        ESP_LOGI(TAG, "Config not in NVS. Assembling from embedded defaults.");
        err = load_config_from_defaults();
        if (err == ESP_OK)
        {
            save_config_to_nvs();
        }
    }

    if (config_root_node == NULL)
    {
        ESP_LOGE(TAG, "CRITICAL: Failed to load any configuration!");
        vSemaphoreDelete(config_mutex);
        config_mutex = NULL;
        return ESP_FAIL;
    }

    ESP_LOGI(TAG, "Config Manager initialized successfully.");
    return ESP_OK;
}

esp_err_t synapse_config_save(void) { return save_config_to_nvs(); }
const cJSON *synapse_config_get_root(void) { return config_root_node; }

esp_err_t synapse_config_get_string(const char *key, char *buffer, size_t buffer_size)
{
    if (!key || !buffer || buffer_size == 0)
    {
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t ret = ESP_FAIL;
    if (xSemaphoreTake(config_mutex, portMAX_DELAY) == pdTRUE)
    {
        const cJSON *item = get_node_by_key(key);
        if (cJSON_IsString(item))
        {
            strncpy(buffer, item->valuestring, buffer_size - 1);
            buffer[buffer_size - 1] = '\0';
            ret = ESP_OK;
        }
        else
        {
            ret = item ? ESP_ERR_NVS_TYPE_MISMATCH : ESP_ERR_NOT_FOUND;
        }
        xSemaphoreGive(config_mutex);
    }
    else
    {
        ret = ESP_ERR_TIMEOUT;
    }
    return ret;
}

esp_err_t synapse_config_get_int(const char *key, int *out_value)
{
    if (!key || !out_value)
    {
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t ret = ESP_FAIL;
    if (xSemaphoreTake(config_mutex, portMAX_DELAY) == pdTRUE)
    {
        const cJSON *item = get_node_by_key(key);
        if (cJSON_IsNumber(item))
        {
            *out_value = item->valueint;
            ret = ESP_OK;
        }
        else
        {
            ret = item ? ESP_ERR_NVS_TYPE_MISMATCH : ESP_ERR_NOT_FOUND;
        }
        xSemaphoreGive(config_mutex);
    }
    else
    {
        ret = ESP_ERR_TIMEOUT;
    }
    return ret;
}

esp_err_t synapse_config_get_bool(const char *key, bool *out_value)
{
    if (!key || !out_value)
    {
        return ESP_ERR_INVALID_ARG;
    }

    esp_err_t ret = ESP_FAIL;
    if (xSemaphoreTake(config_mutex, portMAX_DELAY) == pdTRUE)
    {
        const cJSON *item = get_node_by_key(key);
        if (cJSON_IsBool(item))
        {
            *out_value = cJSON_IsTrue(item);
            ret = ESP_OK;
        }
        else
        {
            ret = item ? ESP_ERR_NVS_TYPE_MISMATCH : ESP_ERR_NOT_FOUND;
        }
        xSemaphoreGive(config_mutex);
    }
    else
    {
        ret = ESP_ERR_TIMEOUT;
    }
    return ret;
}

const cJSON *synapse_config_get_global_config(void)
{
    if (!config_root_node)
        return NULL;
    // ეს ფუნქცია არ იღებს mutex-ს, რადგან ის იძახებს get_node_by_key-ს,
    // რომელიც თავის მხრივ არ არის ნაკად-უსაფრთხო.
    // გარე გამოყენებისთვის გამოიძახეთ synapse_config_get_* ფუნქციები.
    return cJSON_GetObjectItem(config_root_node, "global_config");
}

// =========================================================================
//                      Internal Functions
// =========================================================================

/**
 * @internal
 * @brief პოულობს მოდულის კონფიგურაციას მისი `instance_name`-ის მიხედვით.
 * @details ეს ფუნქცია არ არის ნაკად-უსაფრთხო და უნდა გამოიძახოს მხოლოდ mutex-ით დაცულ კონტექსტში.
 * @param module_name მოსაძებნი მოდულის სახელი.
 * @return const cJSON* მოდულის `config` ობიექტზე, ან NULL თუ ვერ მოიძებნა.
 */
static const cJSON *find_module_config_by_name(const char *module_name)
{
    if (!config_root_node || !module_name)
        return NULL;

    const cJSON *modules_array = cJSON_GetObjectItem(config_root_node, "modules");
    if (!cJSON_IsArray(modules_array))
    {
        ESP_LOGD(TAG, "კონფიგურაციაში 'modules' მასივი არ არის ან არასწორი ტიპისაა.");
        return NULL;
    }

    const cJSON *module_item = NULL;
    cJSON_ArrayForEach(module_item, modules_array)
    {
        const cJSON *config = cJSON_GetObjectItem(module_item, "config");
        if (!config)
            continue;

        const cJSON *instance_name = cJSON_GetObjectItem(config, "instance_name");
        if (cJSON_IsString(instance_name) && (strcmp(instance_name->valuestring, module_name) == 0))
        {
            return config; // ვიპოვეთ შესაბამისი მოდული
        }
    }

    return NULL; // მოდული ვერ მოიძებნა
}

/**
 * @internal
 * @brief პოულობს cJSON კვანძს წერტილით გამოყოფილი გასაღების მიხედვით.
 * @details ეს ფუნქცია არ არის ნაკად-უსაფრთხო და უნდა გამოიძახოს მხოლოდ mutex-ით დაცულ კონტექსტში.
 *          იგი არჩევს გასაღებს, მაგ: "module_name.key.subkey" ან "global_config.key".
 * @param key წერტილით გამოყოფილი გასაღები.
 * @return const cJSON* ნაპოვნი კვანძი ან NULL თუ ვერ მოიძებნა.
 */
static const cJSON *get_node_by_key(const char *key)
{
    if (!config_root_node || !key)
    {
        return NULL;
    }

    char *key_copy = strdup(key);
    if (!key_copy)
    {
        ESP_LOGE(TAG, "გასაღების დუბლირებისთვის მეხსიერება ვერ გამოიყო.");
        return NULL;
    }

    const cJSON *current_node = NULL;
    char *token = strtok(key_copy, ".");

    if (!token)
    {
        free(key_copy);
        return NULL;
    }

    // შევამოწმოთ, გლობალური კონფიგურაციაა თუ მოდულის
    if (strcmp(token, "global_config") == 0)
    {
        current_node = cJSON_GetObjectItem(config_root_node, "global_config");
    }
    else
    {
        // ვივარაუდოთ, რომ პირველი ტოკენი არის მოდულის instance_name
        current_node = find_module_config_by_name(token);
    }

    // დანარჩენი გასაღების დამუშავება
    while (current_node && (token = strtok(NULL, ".")))
    {
        current_node = cJSON_GetObjectItem(current_node, token);
    }

    free(key_copy);
    return current_node;
}

static esp_err_t load_config_from_nvs(void)
{
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open(NVS_NAMESPACE, NVS_READONLY, &nvs_handle);
    if (err != ESP_OK)
        return err;

    size_t required_size = 0;
    err = nvs_get_str(nvs_handle, NVS_FULL_CONFIG_KEY, NULL, &required_size);
    if (err != ESP_OK || required_size <= 1)
    {
        nvs_close(nvs_handle);
        return ESP_ERR_NVS_NOT_FOUND;
    }

    char *json_string = malloc(required_size);
    if (!json_string)
    {
        nvs_close(nvs_handle);
        return ESP_ERR_NO_MEM;
    }

    err = nvs_get_str(nvs_handle, NVS_FULL_CONFIG_KEY, json_string, &required_size);
    nvs_close(nvs_handle);

    if (err == ESP_OK)
    {
        cJSON *temp_node = cJSON_Parse(json_string);
        if (temp_node)
        {
            if (xSemaphoreTake(config_mutex, portMAX_DELAY) == pdTRUE)
            {
                if (config_root_node)
                    cJSON_Delete(config_root_node);
                config_root_node = temp_node;
                xSemaphoreGive(config_mutex);
                ESP_LOGI(TAG, "Configuration loaded successfully from NVS.");
            }
        }
        else
        {
            err = ESP_FAIL;
        }
    }
    free(json_string);
    return err;
}

static esp_err_t load_config_from_defaults(void)
{
    extern const uint8_t _binary_system_config_json_start[] asm("_binary_system_config_json_start");
    extern const uint8_t _binary_system_config_json_end[] asm("_binary_system_config_json_end");
    size_t base_json_size = _binary_system_config_json_end - _binary_system_config_json_start;

    cJSON *root = cJSON_ParseWithLength((const char *)_binary_system_config_json_start, base_json_size);
    if (!root)
    {
        ESP_LOGE(TAG, "Failed to parse embedded base system_config.json!");
        return ESP_FAIL;
    }

    cJSON *modules_array = cJSON_GetObjectItem(root, "modules");
    if (!modules_array)
    {
        modules_array = cJSON_CreateArray();
        cJSON_AddItemToObject(root, "modules", modules_array);
    }

    int modules_added = 0;
    for (int i = 0; embedded_module_configs[i].module_name != NULL; i++)
    {
        const embedded_config_t *entry = &embedded_module_configs[i];
        size_t size = get_embedded_config_size(entry);
        if (size == 0)
            continue;

        cJSON *parsed_json = cJSON_ParseWithLength((const char *)entry->start, size);
        if (!parsed_json)
        {
            ESP_LOGE(TAG, "Failed to parse config for module '%s'.", entry->module_name);
            continue;
        }

        if (cJSON_IsArray(parsed_json))
        {
            cJSON *element;
            while ((element = cJSON_DetachItemFromArray(parsed_json, 0)) != NULL)
            {
                cJSON_AddItemToArray(modules_array, element);
                modules_added++;
            }
            cJSON_Delete(parsed_json);
        }
        else if (cJSON_IsObject(parsed_json))
        {
            cJSON_AddItemToArray(modules_array, parsed_json);
            modules_added++;
        }
        else
        {
            cJSON_Delete(parsed_json);
        }
    }

    ESP_LOGI(TAG, "Assembled default configuration with %d modules.", modules_added);

    if (xSemaphoreTake(config_mutex, portMAX_DELAY) == pdTRUE)
    {
        if (config_root_node)
            cJSON_Delete(config_root_node);
        config_root_node = root;
        xSemaphoreGive(config_mutex);
    }
    else
    {
        cJSON_Delete(root);
        return ESP_ERR_TIMEOUT;
    }

    return ESP_OK;
}

static esp_err_t save_config_to_nvs(void)
{
    if (xSemaphoreTake(config_mutex, portMAX_DELAY) != pdTRUE)
        return ESP_ERR_TIMEOUT;

    char *json_string = cJSON_PrintUnformatted(config_root_node);
    if (!json_string)
    {
        xSemaphoreGive(config_mutex);
        return ESP_ERR_NO_MEM;
    }

    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open(NVS_NAMESPACE, NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK)
    {
        err = nvs_set_str(nvs_handle, NVS_FULL_CONFIG_KEY, json_string);
        if (err == ESP_OK)
        {
            err = nvs_commit(nvs_handle);
        }
        nvs_close(nvs_handle);
    }

    free(json_string);
    xSemaphoreGive(config_mutex);

    if (err != ESP_OK)
    {
        ESP_LOGW(TAG, "Failed to save full config to NVS: %s. This is expected if config > 4KB.", esp_err_to_name(err));
    }
    else
    {
        ESP_LOGI(TAG, "Full configuration saved to NVS successfully.");
    }
    return err;
}