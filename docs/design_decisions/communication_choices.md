# კომუნიკაციის არქიტექტურული არჩევანი (Communication Choices)

---

## მიზანი

ეს დოკუმენტი აღწერს Synapse ESP Framework-ში მოდულებს შორის კომუნიკაციის არქიტექტურულ არჩევანს, არჩეული პატერნების მოტივაციას, ალტერნატივებს და საბოლოო გადაწყვეტილების შედეგებს naming/structure კონვენციების დაცვით.

---

## კონტექსტი

Synapse Framework-ის მიზანია მაქსიმალური მოდულურობა და იზოლაცია. მოდულებს შორის კომუნიკაცია უნდა იყოს სტანდარტიზებული, მარტივად გასაფართოებელი და მინიმალური დამოკიდებულებით. საჭიროა ისეთი არქიტექტურული გადაწყვეტა, რომელიც უზრუნველყოფს როგორც პირდაპირი API-კოლების, ისე ასინქრონული შეტყობინებების მხარდაჭერას.

---

## არჩეული გადაწყვეტილება

ფრეიმვორქში არჩეულია ორი ძირითადი კომუნიკაციის პატერნი:

1. **Service Locator Pattern** — გამოიყენება კონკრეტული API-ს მისაღებად და პირდაპირი ფუნქციური გამოძახებისთვის.
2. **Event Bus Pattern** — გამოიყენება broadcast/notification სცენარებისთვის, როცა ერთზე მეტ მოდულს სჭირდება ერთი მოვლენის მიღება.

---

## არგუმენტები და მოტივაცია

- **Service Locator** უზრუნველყოფს მოდულებს შორის მინიმალურ დამოკიდებულებას და პირდაპირი API-კოლების სტანდარტიზაციას.
- **Event Bus** უზრუნველყოფს loosely-coupled, ასინქრონულ კომუნიკაციას და მარტივ გაფართოებადობას.
- ორივე პატერნი ხელს უწყობს მოდულების დამოუკიდებლობას, ტესტირებადობას და სისტემის სტაბილურობას.
- ალტერნატივა (პირდაპირი #include ან გლობალური ცვლადები) უარყოფილია იზოლაციისა და გაფართოებადობის დარღვევის გამო.

---

## შედეგები და გავლენა

- მოდულებს შორის პირდაპირი დამოკიდებულება გამორიცხულია
- შესაძლებელია როგორც სინქრონული, ისე ასინქრონული კომუნიკაცია
- სისტემის გაფართოება და ახალი მოდულების დამატება მარტივია
- Event Bus-ის debug შეიძლება იყოს შედარებით რთული

---

## გამოყენების მაგალითები

### Service Locator
```c
service_handle_t display_service_handle = fmw_service_get("main_display");
if (display_service_handle) {
    ssd1306_api_t *ssd1306_service_api = (ssd1306_api_t *)display_service_handle;
    ssd1306_service_api->enable();
}
```

### Event Bus
```c
telemetry_data_t sensor_telemetry_data = {
    .temperature = 23.5,
    .humidity = 65.2
};
event_bus_post(TELEMETRY_EVENT_SENSOR_DATA, &sensor_telemetry_data);
event_bus_subscribe(TELEMETRY_EVENT_SENSOR_DATA, mqtt_handle_sensor_data);
```

---

## აკრძალული და რეკომენდებული პრაქტიკები

❌ **არასდროს:**
- პირდაპირი #include სხვა მოდულის header-ების
- გლობალური ცვლადების გამოყენება მოდულებს შორის
- Event Bus და Service Locator-ის არასწორი მიქსი ერთსა და იმავე მიზნისთვის

✅ **ყოველთვის:**
- გამოიყენეთ მხოლოდ Service Locator ან Event Bus პატერნები
- დაიცავით communication_patterns.md-ში აღწერილი წესები
- ჩაწერეთ ყველა ცვლილება და კომუნიკაციის არქიტექტურული გადაწყვეტილება დოკუმენტაციაში

---

## დაკავშირებული დოკუმენტები

- [core_components.md](core_components.md)
- [communication_patterns.md](../convention/communication_patterns.md)
- [architecture_overview.md](architecture_overview.md)
- [structure/faq.md](../structure/faq.md)

---

_დამატებითი კითხვებისთვის იხილეთ შესაბამისი დოკუმენტაცია ან მიმართეთ გუნდის დოკუმენტაციის პასუხისმგებელ პირს._

