# უსაფრთხოების არქიტექტურული გადაწყვეტილებები (Security Considerations)

---

## მიზანი

ეს დოკუმენტი აღწერს Synapse ESP Framework-ში უსაფრთხოების არქიტექტურულ გადაწყვეტილებებს, არჩეულ best practices, ალტერნატივებს და საბოლოო გადაწყვეტილების შედეგებს naming/structure კონვენციების დაცვით.

---

## კონტექსტი

ფრეიმვორქს სჭირდება უსაფრთხოების ისეთი მექანიზმები, რომლებიც დაიცავს როგორც სისტემურ, ისე მოდულების დონეზე მონაცემებს, კომუნიკაციას და firmware-ს. აუცილებელია როგორც მინიმალური თავდაცვა (default), ისე გაფართოებადი უსაფრთხოების პოლიტიკა.

---

## არჩეული გადაწყვეტილებები

- **კომუნიკაციის დაშიფვრა:** გამოიყენება TLS/SSL ყველა გარე სერვისთან (მაგ: MQTT, REST API)
- **კონფიგურაციის დაცვა:** კონფიგურაციის ფაილები და პარამეტრები ინახება მხოლოდ NVS-ში ან დაშიფრულ storage-ში
- **Firmware-ის სანდოობა:** გამოიყენება სიგნირებული და დაშიფრული OTA განახლებები
- **Authentication/Authorization:** ყველა გარე სერვისთან კავშირი მოითხოვს ავთენტიკაციას (მაგ: MQTT username/password, REST API token)
- **Input Validation:** ყველა მოდული ასრულებს პარამეტრების ვალიდაციას
- **Logging-ის კონტროლი:** ლოგებში არ იწერება სენსიტიური ინფორმაცია (პაროლები, ტოკენები)

---

## არგუმენტები და მოტივაცია

- დაშიფრული კომუნიკაცია იცავს მონაცემებს გადაცემისას
- სიგნირებული firmware იცავს მოწყობილობას მავნე განახლებებისგან
- კონფიგურაციის დაცვა ამცირებს credentials-ის გაჟონვის რისკს
- ლოგირების კონტროლი იცავს სენსიტიურ ინფორმაციას შემთხვევითი გაჟონვისგან
- ალტერნატივა (plain communication, unsecured OTA) უარყოფილია უსაფრთხოების სერიოზული რისკების გამო

---

## შედეგები და გავლენა

- მონაცემები და firmware დაცულია როგორც გადაცემისას, ისე შენახვისას
- სისტემის თავდაცვა უზრუნველყოფილია როგორც მინიმალური, ისე გაფართოებადი პოლიტიკით
- უსაფრთხოების best practices დაცვა ამარტივებს სერტიფიცირებას და მომხმარებლის ნდობას
- უსაფრთხოების დამატებითი მექანიზმები ზრდის სისტემის კომპლექსურობას

---

## გამოყენების მაგალითები

### TLS/SSL ჩართვა MQTT-ში
```c
mqtt_module_config_t mqtt_cfg = {
    .broker_uri = "mqtts://broker.synapse.local:8883",
    .username = "user",
    .password = "pass",
    .use_tls = true
};
```

### OTA განახლების სიგნირება
```c
// გამოიყენეთ esp_ota_set_boot_partition და სიგნირებული firmware
```

### ლოგირების კონტროლი
```c
ESP_LOGI(TAG, "MQTT connected to broker: %s", broker_url); // არ ჩაწეროთ პაროლი ლოგში
```

---

## აკრძალული და რეკომენდებული პრაქტიკები

❌ **არასდროს:**
- credentials-ის, პაროლების ან ტოკენების ლოგირება
- დაუშიფრავი კომუნიკაცია გარე სერვისებთან
- დაუცველი OTA განახლებები
- input validation-ის გამოტოვება

✅ **ყოველთვის:**
- გამოიყენეთ TLS/SSL ყველა გარე კომუნიკაციაზე
- დაიცავით კონფიგურაციის ფაილები და credentials
- გამოიყენეთ სიგნირებული და დაშიფრული firmware
- ჩაწერეთ ყველა უსაფრთხოების გადაწყვეტილება დოკუმენტაციაში

---

## დაკავშირებული დოკუმენტები

- [core_components.md](core_components.md)
- [architecture_overview.md](architecture_overview.md)
- [configuration_management.md](../convention/configuration_management.md)
- [logging_standards.md](../convention/logging_standards.md)

---

_დამატებითი კითხვებისთვის იხილეთ შესაბამისი დოკუმენტაცია ან მიმართეთ გუნდის დოკუმენტაციის პასუხისმგებელ პირს._

