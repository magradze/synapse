# Synapse ESP Framework — არქიტექტურის მიმოხილვა

## მიზანი

Synapse ESP Framework-ის არქიტექტურა შექმნილია იმისთვის, რომ უზრუნველყოს მოდულური, გაფართოებადი და სტანდარტიზებული ჩაშენებული სისტემების (embedded systems) განვითარება ESP-IDF ეკოსისტემაში. მთავარი პრინციპებია მოდულურობა, იზოლაცია, ავტომატიზაცია და მაღალი ხარისხის კოდის უზრუნველყოფა.

## ძირითადი არქიტექტურული პრინციპები

- **მოდულურობა:** ყველა ფუნქციონალი წარმოდგენილია დამოუკიდებელი მოდულების სახით, რომლებიც შეიძლება ჩაერთოს ან გამოირთოს კონფიგურაციით.
- **იზოლაცია:** მოდულებს შორის პირდაპირი დამოკიდებულებები აკრძალულია. კომუნიკაცია ხდება მხოლოდ Service Locator-ის ან Event Bus-ის მეშვეობით.
- **სტანდარტიზაცია:** ყველა მოდული და ინფრასტრუქტურა მიჰყვება ერთიან naming, structure და communication სტანდარტებს.
- **გაფართოებადობა:** ახალი მოდულის დამატება შესაძლებელია მინიმალური ძალისხმევით.
- **ავტომატიზაცია:** მოდულების ჩართვა/გამორთვა და ბილდში მოხვედრა სრულად ავტომატიზირებულია Kconfig და CMake სისტემების გამოყენებით.
- **დოკუმენტირებულობა:** ყველა არქიტექტურული გადაწყვეტილება და სტანდარტი აღწერილია შესაბამის დოკუმენტებში.

## არქიტექტურული ფენები და ძირითადი კომპონენტები

1. **Core (ბირთვი):**
   - Service Locator — მოდულებს შორის API-ს მოძიება და გამოძახება იზოლაციის დაცვით
   - Event Bus — broadcast/notification ტიპის კომუნიკაცია მოდულებს შორის
   - Module Register — მოდულების რეგისტრაცია, ინიციალიზაცია და მართვა
   - Module Factory — მოდულების დინამიური შექმნა კონფიგურაციიდან
   - Configuration Manager — სისტემის და მოდულების კონფიგურაციის მართვა
   - Logging — სტანდარტიზებული ლოგირება

2. **Interfaces:**
   - გლობალური ინტერფეისები, რომლებიც უზრუნველყოფს მოდულებს შორის კონტრაქტებს

3. **Modules:**
   - კატეგორიებად დაყოფილი ფუნქციონალური გაფართოებები (სენსორები, აქტუატორები, კომუნიკაციები, ეკრანები, დრაივერები, სისტემური და დამხმარე მოდულები)

4. **Configuration:**
   - მოქნილი და სტანდარტიზებული კონფიგურაციის სისტემა (system_config.json, module.json, Kconfig)

## მოდულებს შორის კომუნიკაციის პატერნები

- **Service Locator Pattern:** გამოიყენება კონკრეტული API-ს მისაღებად და პირდაპირი ფუნქციური გამოძახებისთვის. უზრუნველყოფს მოდულებს შორის მინიმალურ დამოკიდებულებას.
- **Event Bus Pattern:** გამოიყენება broadcast/notification სცენარებისთვის, როცა ერთზე მეტ მოდულს სჭირდება ერთი მოვლენის მიღება.
- **აკრძალულია:** პირდაპირი დამოკიდებულება მოდულებს შორის და სხვა მოდულის header-ის პირდაპირი ჩასმა (#include).

## სიცოცხლის ციკლი

- **Create:** მოდულის ობიექტის შექმნა და კონფიგურაციის გადაცემა
- **Init:** hardware-ის ან სხვა რესურსების ინიციალიზაცია
- **Enable/Disable:** მოდულის აქტივაცია ან დროებით გათიშვა
- **Deinit:** ყველა გამოყოფილი რესურსის გათავისუფლება

## საქაღალდეებისა და ფაილების სტრუქტურა

- **main/** — მთავარი აპლიკაცია (app_main და ძირითადი ლოგიკა)
- **components/core/** — ბირთვი: service locator, event bus, module register და სხვა
- **components/interfaces/** — გლობალური ინტერფეისები
- **components/modules/** — კატეგორიებად დაყოფილი მოდულები
- **docs/** — დოკუმენტაცია და სტანდარტები

## არქიტექტურული დიაგრამა (მოკლე)

```
┌──────────────┐      Service Locator     ┌──────────────┐
│   Module A   │ ───────────────────────► │   Module B   │
└──────────────┘                          └──────────────┘
        │
        │ Event Bus
        ▼
┌──────────────┐
│   Module C   │
└──────────────┘
```

## სტანდარტები და დოკუმენტაცია

ყველა naming, structure, communication და სხვა წესები აღწერილია შესაბამის convention დოკუმენტებში:
- variable_naming.md
- function_naming.md
- module_structure.md
- configuration_management.md
- communication_patterns.md
- error_handling.md
- logging_standards.md
- coding_doxygen_standard.md

## დასკვნა

Synapse ESP Framework-ის არქიტექტურა უზრუნველყოფს მოქნილ, სტანდარტიზებულ და გაფართოებად ჩაშენებულ სისტემებს, სადაც თითოეული მოდული დამოუკიდებელია, ადვილად ტესტირებადი და დოკუმენტირებულია. ყველა გადაწყვეტილება და სტანდარტი დეტალურადაა აღწერილი დოკუმენტაციაში, რაც ამარტივებს როგორც ახალ, ისე გამოცდილ დეველოპერებს ჩართვას და განვითარებას.
