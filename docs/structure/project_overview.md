# პროექტის მიმოხილვა (Project Overview)

## მიზანი

Synapse ESP Framework-ის მიზანია უზრუნველყოს მოდულური, გაფართოებადი და ავტომატიზირებული ჩაშენებული სისტემების (embedded systems) პლატფორმა ESP-IDF ეკოსისტემისთვის. ფრეიმვორქი საშუალებას აძლევს დეველოპერებს მინიმალური ძალისხმევით შექმნან, ჩართონ ან გამორთონ სხვადასხვა ფუნქციონალი (სენსორები, აქტუატორები, კომუნიკაციები და სხვა), მიიღონ მაქსიმალურად მცირე და ოპტიმიზირებული firmware და უზრუნველყონ კოდის მაღალი ხარისხი.

## არქიტექტურული ხედვა

- **მოდულურობა:** ყველა ფუნქციონალი წარმოდგენილია დამოუკიდებელი მოდულების სახით, რომლებიც შეიძლება ჩაერთოს ან გამოირთოს კონფიგურაციით.
- **იზოლაცია:** მოდულებს შორის პირდაპირი დამოკიდებულებები აკრძალულია. კომუნიკაცია ხდება მხოლოდ Service Locator-ის ან Event Bus-ის მეშვეობით.
- **ავტომატიზაცია:** მოდულების ჩართვა/გამორთვა და ბილდში მოხვედრა სრულად ავტომატიზირებულია Kconfig და CMake სისტემების გამოყენებით.
- **სტანდარტიზაცია:** ყველა კოდის ნაწილი და დოკუმენტაცია მიჰყვება მკაცრ naming, structure და communication convention-ებს.

## ძირითადი პრინციპები

1. **მაქსიმალური იზოლაცია** — მოდულებს შორის მხოლოდ განსაზღვრული არხებით ხდება ურთიერთქმედება.
2. **მინიმალური firmware** — მხოლოდ არჩეული მოდულები მოხვდება საბოლოო ბილდში.
3. **მარტივი გაფართოებადობა** — ახალი მოდულის დამატება შესაძლებელია მინიმალური ძალისხმევით.
4. **კოდის ერთგვაროვნება** — ყველა მოდული და ინფრასტრუქტურა მიჰყვება ერთიან naming და structure სტანდარტებს.
5. **დოკუმენტირებული არქიტექტურა** — ყველა არქიტექტურული გადაწყვეტილება და სტანდარტი აღწერილია შესაბამის დოკუმენტებში.

## ძირითადი კომპონენტები

- **Core** — ბირთვი, რომელიც მოიცავს service locator-ს, event bus-ს, module register-ს და სხვა ინფრასტრუქტურულ ნაწილებს.
- **Interfaces** — გლობალური ინტერფეისები, რომლებიც უზრუნველყოფს მოდულებს შორის კონტრაქტებს.
- **Modules** — კატეგორიებად დაყოფილი ფუნქციონალური გაფართოებები (სენსორები, აქტუატორები, კომუნიკაციები და ა.შ.).
- **Configuration** — მოქნილი და სტანდარტიზებული კონფიგურაციის სისტემა.

## არქიტექტურული დიაგრამა (მოკლე)

```
┌──────────────┐      Service Locator     ┌──────────────┐
│   Module A   │ ───────────────────────► │   Module B   │
└──────────────┘                          └──────────────┘
        │
        │ Event Bus
        ▼
┌──────────────┐
│   Module C   │
└──────────────┘
```

## სტანდარტებზე დაყრდნობით

ყველა დეტალი, naming, structure, communication და სხვა წესები აღწერილია შესაბამის convention დოკუმენტებში:
- variable_naming.md
- function_naming.md
- module_structure.md
- configuration_management.md
- communication_patterns.md
- error_handling.md
- logging_standards.md
- coding_doxygen_standard.md

---

შემდეგი ნაბიჯი: დეტალურად განვიხილოთ საქაღალდის სტრუქტურა და მოდულების არქიტექტურა.

