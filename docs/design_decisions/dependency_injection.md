# არქიტექტურული გადაწყვეტილება: დამოკიდებულებების ინექცია (Dependency Injection)

## 1. კონტექსტი

Synapse Framework-ის ერთ-ერთი მთავარი მიზანია მოდულებს შორის მაქსიმალური იზოლაციის მიღწევა. საწყის ვერსიებში, მოდული, რომელსაც სჭირდებოდა სხვა მოდულის სერვისი, იძახებდა `fmw_service_get("service_instance_name")` ფუნქციას თავის `_init` ფაზაში.

**პრობლემა:**
ეს მიდგომა, მიუხედავად იმისა, რომ მუშაობს, ქმნის რამდენიმე არქიტექტურულ გამოწვევას:

- **"რბილი" დამოკიდებულება:** მოდულის კოდში ჩაშენებულია (`hardcoded`) დამოკიდებული სერვისის კონკრეტული `instance_name`, რაც ართულებს კონფიგურაციის ცვლილებას.
- **ტესტირების გართულება:** შეუძლებელია მოდულის იზოლირებულად ტესტირება "ყალბი" (mock) სერვისის მარტივად ჩანაცვლებით.
- **"ვინ ვის შემდეგ?" პრობლემა:** დეველოპერი თავად უნდა ზრუნავდეს `init_level`-ების სწორად დალაგებაზე, რათა სერვისის მომხმარებელი არ ცდილობდეს სერვისის გამოყენებას მის ინიციალიზაციამდე.

## 2. გადაწყვეტილება

მიღებულ იქნა გადაწყვეტილება, დაინერგოს **კონფიგურაციაზე-დაფუძნებული დამოკიდებულებების ინექციის (Configuration-based Dependency Injection)** მექანიზმი.

ამ მოდელის მიხედვით, `System Manager` სისტემის გაშვებისას, მოდულების `_init` ფუნქციების გამოძახებამდე, ასრულებს შემდეგ მოქმედებებს:

1. **სკანირება:** აანალიზებს თითოეული მოდულის `config.json` ფაილს.
2. **აღმოჩენა:** პოულობს კონფიგურაციის იმ ველებს, რომლებიც მთავრდება `_service` სუფიქსით (მაგ., `expander_service`).
3. **მოძიება:** იღებს სერვისის სახელს (მაგ., `"main_io_expander"`) და `Service Locator`-ის მეშვეობით პოულობს შესაბამის სერვისის `handle`-ს.
4. **ინექცია:** "შეჰყავს" (injects) ნაპოვნი `handle` პირდაპირ მომხმარებელი მოდულის `private_data` სტრუქტურაში.

შედეგად, როდესაც მოდულის `_init` ფუნქცია გამოიძახება, მას უკვე გამზადებული და ვალიდური `handle` ხვდება თავის `private_data`-ში.

## 3. არგუმენტები და მოტივაცია

- **სრული იზოლაცია (Inversion of Control):** მოდული აღარ არის პასუხისმგებელი თავისი დამოკიდებულებების მოძიებაზე. ამ პასუხისმგებლობას თავის თავზე იღებს ფრეიმვორქი (`System Manager`). მოდული უბრალოდ აცხადებს, რა სჭირდება და იღებს მას.
- **გაუმჯობესებული ტესტირება:** ტესტირებისას შესაძლებელია, მოდულს გადაეცეს "ყალბი" (mock) სერვისის `handle`, რაც იძლევა მისი ლოგიკის სრულად იზოლირებულად შემოწმების საშუალებას.
- **კონფიგურაციის მოქნილობა:** დამოკიდებულებები იმართება ცენტრალიზებულად, `config.json` ფაილებით. სერვისის სახელის შეცვლა არ საჭიროებს კოდში ცვლილების შეტანას.
- **გამარტივებული მოდულის კოდი:** მოდულების `_init` ფუნქციები თავისუფლდება `fmw_service_get` გამოძახებებისგან და ხდება უფრო სუფთა და ფოკუსირებული.

## 4. შედეგები და გავლენა

### 4.1. კონვენცია მოდულის დეველოპერებისთვის

ამ მექანიზმის გამართულად მუშაობისთვის, მოდულის დეველოპერმა უნდა დაიცვას **ორი მკაცრი კონვენცია**:

1. **კონფიგურაციის გასაღები:** `config.json`-ში, დამოკიდებულების აღმწერ ველს უნდა ჰქონდეს `_service` სუფიქსი.

    ```json
    "expander_service": "main_io_expander"
    ```

2. **`private_data` სტრუქტურა:** მოდულის `private_data` სტრუქტურაში, შესაბამისი სერვისის `handle`-ის მაჩვენებელი **აუცილებლად უნდა იყოს პირველი წევრი**.

    ```c
    // button_input.c-ში
    typedef struct {
        mcp23017_handle_t *expander_handle; // აუცილებლად პირველი!
        char instance_name[32];
        // ... სხვა ველები
    } button_input_private_data_t;
    ```

    *ეს კონვენცია საშუალებას აძლევს `System Manager`-ს, უსაფრთხოდ და ზოგადად ჩაწეროს `handle`-ის მისამართი `private_data`-ს დასაწყისში, სტრუქტურის შიდა განლაგების ცოდნის გარეშე.*

### 4.2. გამოყენების მაგალითი

**ძველი მიდგომა (`button_input_init`-ში):**

```c
// მოდული თავად ეძებს სერვისს
private_data->expander_handle = (mcp23017_handle_t *)fmw_service_get(private_data->expander_service_name);
if (!private_data->expander_handle) {
    ESP_LOGE(TAG, "Expander service '%s' not found!", ...);
    return ESP_ERR_NOT_FOUND;
}
```

**ახალი მიდგომა (`button_input_init`-ში):**

```c
// მოდული უბრალოდ ამოწმებს, მოხდა თუ არა ინექცია
if (!private_data->expander_handle) {
    ESP_LOGE(TAG, "Dependency injection failed: expander_handle is NULL!");
    return ESP_ERR_INVALID_STATE;
}
// handle უკვე მზადაა გამოსაყენებლად
private_data->expander_handle->api->set_pin_direction(...);
```

## 5. დაკავშირებული დოკუმენტები

- [system_manager.c](../../components/core/src/system_manager.c)
- [module_structure.md](../convention/module_structure.md)
- [architecture_overview.md](./architecture_overview.md)
