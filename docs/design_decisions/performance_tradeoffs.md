# წარმადობისა და რესურსების არქიტექტურული კომპრომისები (Performance Trade-offs)

---

## მიზანი

ეს დოკუმენტი აღწერს Synapse ESP Framework-ში წარმადობისა და რესურსების არქიტექტურულ კომპრომისებს, არჩეულ სტრატეგიებს, მოტივაციას, ალტერნატივებს და საბოლოო გადაწყვეტილების შედეგებს naming/structure კონვენციების დაცვით.

---

## კონტექსტი

ფრეიმვორქი უნდა იყოს ოპტიმიზირებული როგორც მცირე რესურსების მქონე, ისე მაღალი წარმადობის მოთხოვნების მქონე სისტემებისთვის. საჭიროა ბალანსი მოდულურობასა და მინიმალურ footprint-ს შორის, ასევე latency-სა და გაფართოებადობას შორის.

---

## არჩეული სტრატეგიები

- **მოდულური არქიტექტურა:** მხოლოდ არჩეული მოდულები შედის საბოლოო firmware-ში
- **კონფიგურირებადი ბილდი:** Kconfig და CMake უზრუნველყოფს არასაჭირო კომპონენტების გამორთვას
- **Static Allocation სადაც შესაძლებელია:** stack/queue-ების ზომები წინასწარ განისაზღვრება
- **Lazy Initialization:** რესურსები ინიციალიზდება მხოლოდ საჭიროებისას
- **Async Event Bus:** ასინქრონული კომუნიკაცია ამცირებს latency-ს და ზრდის responsiveness-ს

---

## არგუმენტები და მოტივაცია

- მოდულური არქიტექტურა ამცირებს firmware-ს ზომას და RAM-ის მოხმარებას
- Static allocation ამცირებს fragmentation-ს და runtime შეცდომებს
- Lazy initialization ამცირებს startup დროს და რესურსების ზედმეტ გამოყენებას
- Async Event Bus ზრდის სისტემის რეაგირების სისწრაფეს
- ალტერნატივა (მონოლითური არქიტექტურა, მხოლოდ dynamic allocation) უარყოფილია footprint-ის ზრდისა და სტაბილურობის გამო

---

## შედეგები და გავლენა

- firmware-ს ზომა და RAM-ის მოხმარება მინიმუმამდეა დაყვანილი
- სისტემის რეაგირების დრო (latency) დაბალია
- შესაძლებელია სისტემის ოპტიმიზაცია კონკრეტული აპლიკაციისთვის
- Static allocation ამცირებს მოქნილობას ზოგიერთ სცენარში

---

## გამოყენების მაგალითები

### მოდულის გამორთვა ბილდიდან
```c
// Kconfig-ში მოდულის გამორთვა
CONFIG_RELAY_MODULE=n
```

### Static allocation
```c
#define COMMAND_QUEUE_SIZE 8
static QueueHandle_t command_queue;
command_queue = xQueueCreate(COMMAND_QUEUE_SIZE, sizeof(command_t));
```

### Lazy initialization
```c
if (!global_ssd1306_instance) {
    global_ssd1306_instance = malloc(sizeof(ssd1306_private_data_t));
    // ...init...
}
```

---

## აკრძალული და რეკომენდებული პრაქტიკები

❌ **არასდროს:**
- ყველა მოდულის ჩართვა ერთ ბილდში საჭიროების გარეშე
- მხოლოდ dynamic allocation-ის გამოყენება
- რესურსების გამოუყენებლად დატოვება

✅ **ყოველთვის:**
- გამოიყენეთ მხოლოდ საჭირო მოდულები
- გამოიყენეთ static allocation სადაც შესაძლებელია
- lazy initialization რესურსების ოპტიმალური გამოყენებისთვის
- ჩაწერეთ ყველა ცვლილება და ოპტიმიზაციის გადაწყვეტილება დოკუმენტაციაში

---

## დაკავშირებული დოკუმენტები

- [core_components.md](core_components.md)
- [architecture_overview.md](architecture_overview.md)
- [module_structure.md](../convention/module_structure.md)
- [configuration_management.md](../convention/configuration_management.md)

---

_დამატებითი კითხვებისთვის იხილეთ შესაბამისი დოკუმენტაცია ან მიმართეთ გუნდის დოკუმენტაციის პასუხისმგებელ პირს._

