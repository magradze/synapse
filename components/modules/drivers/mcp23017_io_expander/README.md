# 🔄 მოდული: `mcp23017_io_expander`

**🗂️ კატეგორია:** `drivers`  
**✒️ ავტორი:** Synapse Framework Team  
**🔖 ვერსია:** 1.0.0

## 1. 📜 მიმოხილვა

`mcp23017_io_expander` არის Synapse Framework-ის მძლავრი დრაივერის მოდული, რომელიც უზრუნველყოფს **16-მდე დამატებითი, პროგრამირებადი GPIO პინის** მართვას პოპულარული `MCP23017` I2C I/O Expander ჩიპის გამოყენებით.

მისი მთავარი ამოცანაა, ESP32-ის მხოლოდ ორი I2C პინის (SDA, SCL) გამოყენებით, სისტემას მისცეს საშუალება, მართოს დიდი რაოდენობით შემავალი (ღილაკები, სენსორები) და გამომავალი (LED-ები, რელეები) მოწყობილობები. მოდული სრულად აბსტრაგირებს I2C რეგისტრებთან მუშაობის სირთულეს და სხვა მოდულებს აწვდის მარტივ, `gpio.h`-ის მსგავს API-ს.

## 2. 🏛️ არქიტექტურული პრინციპები

- **სერვისის მომწოდებელი (Pure Service Provider):** ⚙️ მოდული არის სუფთა "სერვისის მომწოდებელი". ის არეგისტრირებს `mcp23017_api_t` სერვისს `Service Locator`-ში, რაც სხვა მოდულებს აძლევს აბსტრაქტულ და მარტივ API-ს გაფართოებული პინების სამართავად.
- **სერვისის მომხმარებელი (Service Consumer):** 🛰️ მოდული არის `i2c_bus` სერვისის მომხმარებელი. ის არ მართავს I2C პერიფერიას პირდაპირ, არამედ იყენებს ცენტრალიზებულ `i2c_bus` სერვისს, რაც უზრუნველყოფს რესურსების კონფლიქტის გარეშე გამოყენებას.
- **ნაკად-უსაფრთხოება (Thread-Safety):** 🔒 თითოეული API ოპერაცია დაცულია `Mutex`-ით, რაც უზრუნველყოფს ჩიპთან უსაფრთხო კომუნიკაციას მრავალტასკიან გარემოში.
- **რეგისტრების ქეშირება:** ⚡️ ეფექტურობის გასაზრდელად, მოდული ინახავს (აკეშირებს) პინების მიმართულების (`IODIR`) და გამომავალი დონის (`GPIO`) რეგისტრების ბოლო ცნობილ მდგომარეობას. ეს ამცირებს I2C ტრანზაქციების რაოდენობას, როდესაც საჭიროა მხოლოდ ერთი ბიტის შეცვლა.
- **ადრეული ინიციალიზაცია (Early Initialization):** 📉 `init_level: 15` უზრუნველყოფს, რომ I/O გამფართოებელი ინიციალიზდება სისტემის გაშვების ადრეულ ეტაპზე, `i2c_bus` მოდულის (`init_level: 10`) შემდეგ, რათა ის ხელმისაწვდომი იყოს ყველა მასზე დამოკიდებული მოდულისთვის.

## 3. ⚙️ კონფიგურაცია (`config.json`)

მოდულის კონფიგურაცია ხდება მისი `config.json` ფაილის საშუალებით.

**კონფიგურაციის მაგალითი:**

```json
[
  {
    "type": "mcp23017_io_expander",
    "enabled": true,
    "config": {
      "instance_name": "main_io_expander",
      "i2c_bus_service": "main_i2c_bus",
      "i2c_addr": "0x20"
    }
  }
]
```

**კონფიგურაციის პარამეტრები:**

| პარამეტრი | ტიპი | აღწერა | სავალდებულო |
| :--- | :--- | :--- | :---: |
| `instance_name` | სტრიქონი | ამ დრაივერის ინსტანციის უნიკალური სახელი. | ✅ |
| `i2c_bus_service` | სტრიქონი | იმ `i2c_bus` სერვისის `instance_name`, რომელსაც ჩიპი უკავშირდება. | ✅ |
| `i2c_addr` | სტრიქონი | ჩიპის 7-ბიტიანი I2C მისამართი ჰექსადეციმალურ ფორმატში (მაგ., `"0x20"`). | ✅ |

## 4. 🔌 Service API (`mcp23017_api_t`)

სხვა მოდულებს შეუძლიათ მიიღონ წვდომა ამ სერვისზე `Service Locator`-ის მეშვეობით. სერვისის ტიპი: **`FMW_SERVICE_TYPE_MCP23017_EXPANDER_API`**.

**API ფუნქციები:**

- **`esp_err_t set_pin_direction(context, pin, direction);`**  
  ↕️ აყენებს ერთი პინის მიმართულებას (INPUT ან OUTPUT).
- **`esp_err_t set_pin_pullup(context, pin, enabled);`**  
  ⬆️ რთავს/თიშავს შიდა 100kΩ Pull-up რეზისტორს (მხოლოდ INPUT პინებისთვის).
- **`esp_err_t set_pin_level(context, pin, level);`**  
  💡 აყენებს გამომავალი პინის ლოგიკურ დონეს (`true`=HIGH, `false`=LOW).
- **`esp_err_t get_pin_level(context, pin, out_level);`**  
  ❓ კითხულობს შემავალი პინის ლოგიკურ დონეს.
- **`esp_err_t write_all_pins(context, value);`**  
  ➡️ ერთდროულად წერს 16-ბიტიან მნიშვნელობას ორივე პორტზე (A და B).
- **`esp_err_t read_all_pins(context, out_value);`**  
  ⬅️ ერთდროულად კითხულობს 16-ბიტიან მნიშვნელობას ორივე პორტიდან.

## 5. 📌 პინების ნუმერაცია და შეერთების სქემა

### 5.1. ლოგიკური და ფიზიკური პინები

ჩვენი დრაივერი მუშაობს **ლოგიკური პინების** ნუმერაციით `0`-დან `15`-მდე. ეს ლოგიკური ნომრები შემდეგნაირად ნაწილდება ჩიპის ორ 8-ბიტიან პორტზე:

- **ლოგიკური პინები 0-7** ➡️ შეესაბამება **PORTA**-ს პინებს (`GPA0` - `GPA7`).
- **ლოგიკური პინები 8-15** ➡️ შეესაბამება **PORTB**-ს პინებს (`GPB0` - `GPB7`).

**ცხრილი:**

| ლოგიკური პინი | ფიზიკური პორტი |
| :--- | :--- |
| 0 | GPA0 |
| ... | ... |
| 7 | GPA7 |
| 8 | GPB0 |
| ... | ... |
| 15 | GPB7 |

### 5.2. ASCII Pinout დიაგრამა (DIP-28 პაკეტი)

```plaintext
              +----\/----+
         GPB0 | 1      28 | GPA7
         GPB1 | 2      27 | GPA6
         GPB2 | 3      26 | GPA5
         GPB3 | 4      25 | GPA4
         GPB4 | 5      24 | GPA3
         GPB5 | 6      23 | GPA2
         GPB6 | 7      22 | GPA1
         GPB7 | 8      21 | GPA0
          VDD | 9      20 | INTA
          VSS | 10     19 | INTB
           NC | 11     18 | RESET
          SCL | 12     17 | A2
          SDA | 13     16 | A1
           NC | 14     15 | A0
              +----------+
```

### 5.3. შეერთების სქემა

`i2c_bus` და `mcp23017_expander` მოდულების default კონფიგურაციისთვის (`sda_pin: 21`, `scl_pin: 22`, `i2c_addr: "0x20"`):

- **ESP32 `3.3V`** ➡️ **MCP23017 `VDD` (პინი 9) და `RESET` (პინი 18)**
- **ESP32 `GND`** ➡️ **MCP23017 `VSS` (პინი 10), `A0` (პინი 15), `A1` (პინი 16), `A2` (პინი 17)**
- **ESP32 `GPIO 21` (SDA)** ➡️ **MCP23017 `SDA` (პინი 13)**
- **ESP32 `GPIO 22` (SCL)** ➡️ **MCP23017 `SCL` (პინი 12)**

**მნიშვნელოვანია:** სტაბილური მუშაობისთვის, რეკომენდებულია **4.7kΩ pull-up რეზისტორების** დამატება SDA და SCL ხაზებზე (თითოეული ხაზიდან 3.3V-ზე).

## 6. 💡 გამოყენების მაგალითი

`button_input` მოდული იყენებს ამ სერვისს, რათა წაიკითხოს ღილაკები, რომლებიც მიერთებულია გაფართოებულ პინებზე.

**`button_input.c`-ში, `init` ფუნქციაში:**

```c
#include "service_locator.h"
#include "mcp23017_interface.h"

// ...

static esp_err_t button_input_init(module_t *self) {
    // ...
    // ვიღებთ I/O Expander სერვისს
    p_data->expander_handle = (mcp23017_handle_t*)fmw_service_get(p_data->expander_service_name);
    if (!p_data->expander_handle) {
        ESP_LOGE(TAG, "Expander service '%s' not found!", p_data->expander_service_name);
        return ESP_ERR_NOT_FOUND;
    }

    // ვაკონფიგურირებთ თითოეულ ღილაკის პინს
    for (int i = 0; i < p_data->button_count; i++) {
        button_config_t *btn = &p_data->buttons[i];
        // ვაყენებთ პინის მიმართულებას INPUT-ზე
        p_data->expander_handle->api->set_pin_direction(p_data->expander_handle->context, btn->pin, MCP23017_DIRECTION_INPUT);
        // ვრთავთ შიდა pull-up რეზისტორს
        p_data->expander_handle->api->set_pin_pullup(p_data->expander_handle->context, btn->pin, true);
    }
    // ...
}
```
