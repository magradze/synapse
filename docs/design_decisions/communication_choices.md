# კომუნიკაციის არქიტექტურული არჩევანი (Communication Choices)

---

## მიზანი

ეს დოკუმენტი აღწერს Synapse ESP Framework-ში მოდულებს შორის კომუნიკაციის არქიტექტურულ არჩევანს, არჩეული პატერნების მოტივაციას, ალტერნატივებს და საბოლოო გადაწყვეტილების შედეგებს naming/structure კონვენციების დაცვით.

---

## კონტექსტი

Synapse Framework-ის მიზანია მაქსიმალური მოდულურობა და იზოლაცია. მოდულებს შორის კომუნიკაცია უნდა იყოს სტანდარტიზებული, მარტივად გასაფართოებელი და მინიმალური დამოკიდებულებით. საჭიროა ისეთი არქიტექტურული გადაწყვეტა, რომელიც უზრუნველყოფს როგორც პირდაპირი API-კოლების, ისე ასინქრონული შეტყობინებების მხარდაჭერას.

---

## არჩეული გადაწყვეტილება

ფრეიმვორქში არჩეულია ორი ძირითადი კომუნიკაციის პატერნი:

1. **Service Locator Pattern** — გამოიყენება კონკრეტული API-ს მისაღებად და პირდაპირი ფუნქციური გამოძახებისთვის.
2. **Event Bus Pattern** — გამოიყენება broadcast/notification სცენარებისთვის, როცა ერთზე მეტ მოდულს სჭირდება ერთი მოვლენის მიღება.

---

## არგუმენტები და მოტივაცია

- **Service Locator** უზრუნველყოფს მოდულებს შორის მინიმალურ დამოკიდებულებას და პირდაპირი API-კოლების სტანდარტიზაციას.
- **Event Bus** უზრუნველყოფს loosely-coupled, ასინქრონულ კომუნიკაციას და მარტივ გაფართოებადობას.
- ორივე პატერნი ხელს უწყობს მოდულების დამოუკიდებლობას, ტესტირებადობას და სისტემის სტაბილურობას.
- ალტერნატივა (პირდაპირი #include ან გლობალური ცვლადები) უარყოფილია იზოლაციისა და გაფართოებადობის დარღვევის გამო.

---

## შედეგები და გავლენა

- მოდულებს შორის პირდაპირი დამოკიდებულება გამორიცხულია
- შესაძლებელია როგორც სინქრონული, ისე ასინქრონული კომუნიკაცია
- სისტემის გაფართოება და ახალი მოდულების დამატება მარტივია
- Event Bus-ის debug შეიძლება იყოს შედარებით რთული

---

## გამოყენების მაგალითები

### Service Locator

```c
service_handle_t display_service_handle = synapse_service_get("main_display");
if (display_service_handle) {
    ssd1306_api_t *ssd1306_service_api = (ssd1306_api_t *)display_service_handle;
    ssd1306_service_api->enable();
}
```

### Event Bus

```c
telemetry_data_t sensor_telemetry_data = {
    .temperature = 23.5,
    .humidity = 65.2
};
event_bus_post(TELEMETRY_EVENT_SENSOR_DATA, &sensor_telemetry_data);
event_bus_subscribe(TELEMETRY_EVENT_SENSOR_DATA, mqtt_handle_sensor_data);
```

---

## აკრძალული და რეკომენდებული პრაქტიკები

❌ **არასდროს:**

- პირდაპირი #include სხვა მოდულის header-ების
- გლობალური ცვლადების გამოყენება მოდულებს შორის
- Event Bus და Service Locator-ის არასწორი მიქსი ერთსა და იმავე მიზნისთვის

✅ **ყოველთვის:**

- გამოიყენეთ მხოლოდ Service Locator ან Event Bus პატერნები
- დაიცავით communication_patterns.md-ში აღწერილი წესები
- ჩაწერეთ ყველა ცვლილება და კომუნიკაციის არქიტექტურული გადაწყვეტილება დოკუმენტაციაში

---

## დაკავშირებული დოკუმენტები

- [core_components.md](core_components.md)
- [communication_patterns.md](../convention/communication_patterns.md)
- [architecture_overview.md](architecture_overview.md)
- [structure/faq.md](../structure/faq.md)

---

## Event Bus Pattern

Event Bus არქიტექტურა არჩეულ იქნა მისი მოქნილობისა და მოდულებს შორის კავშირების შემცირების (loose coupling) უნარის გამო.

### არქიტექტურული ცვლილება: Enum-დან სტრიქონებზე გადასვლა

პროექტის საწყის ეტაპზე ივენთების იდენტიფიკაციისთვის გამოიყენებოდა `enum` ტიპი. თუმცა, სისტემის ზრდასთან ერთად გამოიკვეთა ამ მიდგომის რამდენიმე სისუსტე, რის გამოც მივიღეთ გადაწყვეტილება გადავსულიყავით `const char*` (სტრიქონულ) იდენტიფიკატორებზე.

**გადაწყვეტილების მიზეზები:**

1. **მოქნილობა და გაფართოებადობა:** სტრიქონების გამოყენებისას, ახალი ივენთის დასამატებლად აღარ არის საჭირო ცენტრალური `enum` ფაილის რედაქტირება და მთელი პროექტის ხელახალი კომპილაცია. ნებისმიერ მოდულს შეუძლია განსაზღვროს და გამოიყენოს საკუთარი, ლოკალური ივენთი, რაც ამარტივებს დამოუკიდებელ კომპონენტებზე მუშაობას.
2. **მოდულურობა:** მოდულებს შეუძლიათ განსაზღვრონ საკუთარი ივენთები ისე, რომ არ იყვნენ დამოკიდებული ფრეიმვორქის ბირთვზე. ეს ამცირებს მოდულებს შორის დამოკიდებულებას.
3. **გამართვის სიმარტივე (Debugging):** ლოგებში სტრიქონული სახელი (`"MyCoolEvent"`) ბევრად უფრო ინფორმატიული და მარტივად აღსაქმელია, ვიდრე მაგიური რიცხვი (მაგ. `0x1001`).

**გათვალისწინებული კომპრომისები:**

- **შესრულების სიჩქარე:** სტრიქონების შედარება (`strcmp`) უფრო ნელი ოპერაციაა, ვიდრე მთელი რიცხვების (`enum`) შედარება. თუმცა, ESP32-ის წარმადობის გათვალისწინებით, ეს სხვაობა უმნიშვნელოა ივენთების დამუშავების კონტექსტში.
- **შეცდომის დაშვების რისკი:** სტრიქონების გამოყენებისას იზრდება ბეჭდვითი შეცდომის (typo) დაშვების რისკი. ამის შესამცირებლად, რეკომენდებულია ივენთების სახელების `#define`-ებით განსაზღვრა და ცენტრალიზებულად შენახვა.

### ფრეიმვორქის API-სთან წვდომა: Facade Pattern (`synapse.h`)

არქიტექტურული გადაწყვეტილებით, ფრეიმვორქის ბირთვის ყველა საჯარო API (`Service Locator`, `Event Bus`, `Config Manager` და ა.შ.) გაერთიანდა ერთ, ცენტრალურ ჰედერ ფაილში — `synapse.h`. ეს "ფასადის" პატერნი მნიშვნელოვნად ამარტივებს მოდულების წერას, რადგან დეველოპერს აღარ სჭირდება მრავალი ჰედერის დამახსოვრება და ჩართვა. ნებისმიერ მოდულს შეუძლია, მიიღოს წვდომა ფრეიმვორქის სრულ ფუნქციონალზე მხოლოდ ერთი `#include "synapse.h"` დირექტივით

---

_დამატებითი კითხვებისთვის იხილეთ შესაბამისი დოკუმენტაცია ან მიმართეთ გუნდის დოკუმენტაციის პასუხისმგებელ პირს._
