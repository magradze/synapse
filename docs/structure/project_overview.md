# პროექტის მიმოხილვა (Project Overview)

## მიზანი

Synapse ESP Framework-ის მიზანია უზრუნველყოს მოდულური, გაფართოებადი და ავტომატიზირებული ჩაშენებული სისტემების (embedded systems) პლატფორმა ESP-IDF ეკოსისტემისთვის. ფრეიმვორქი საშუალებას აძლევს დეველოპერებს მინიმალური ძალისხმევით შექმნან, ჩართონ ან გამორთონ სხვადასხვა ფუნქციონალი (სენსორები, აქტუატორები, კომუნიკაციები და სხვა), მიიღონ მაქსიმალურად მცირე და ოპტიმიზირებული firmware და უზრუნველყონ კოდის მაღალი ხარისხი.

## არქიტექტურული ხედვა

- **მოდულურობა:** ყველა ფუნქციონალი წარმოდგენილია დამოუკიდებელი მოდულების სახით, რომლებიც შეიძლება ჩაერთოს ან გამოირთოს კონფიგურაციით.
- **იზოლაცია:** მოდულებს შორის პირდაპირი დამოკიდებულებები აკრძალულია. კომუნიკაცია ხდება მხოლოდ `Service Locator`-ის ან `Event Bus`-ის მეშვეობით.
- **ავტომატიზაცია:** მოდულების აღმოჩენა, build-სისტემაში ინტეგრაცია და `Module Factory`-ის გენერაცია სრულად ავტომატიზირებულია CMake სკრიპტების გამოყენებით.
- **სტანდარტიზაცია:** ყველა კოდის ნაწილი და დოკუმენტაცია მიჰყვება მკაცრ naming, structure და communication კონვენციებს.
- **კონფიგურაციაზე-დაფუძნებული დიზაინი (Configuration-Driven):** **(ახალი)** სისტემის ქცევა და მოდულების შემადგენლობა იმართება დეკლარაციულად, JSON კონფიგურაციის ფაილებით, რაც ამცირებს კოდში ცვლილებების საჭიროებას.

## ძირითადი პრინციპები

1. **მაქსიმალური იზოლაცია** — მოდულებს შორის მხოლოდ განსაზღვრული არხებით ხდება ურთიერთქმედება.
2. **მინიმალური firmware** — მხოლოდ `Kconfig`-ში არჩეული მოდულები ხვდება საბოლოო ბილდში.
3. **მარტივი გაფართოებადობა** — ახალი მოდულის დამატება შესაძლებელია მინიმალური ძალისხმევით, `create_module.py` სკრიპტის დახმარებით.
4. **კოდის ერთგვაროვნება** — ყველა მოდული და ინფრასტრუქტურა მიჰყვება ერთიან naming და structure სტანდარტებს.
5. **დოკუმენტირებული არქიტექტურა** — ყველა არქიტექტურული გადაწყვეტილება და სტანდარტი აღწერილია შესაბამის დოკუმენტებში.

## ძირითადი კომპონენტები

- **Core** — ბირთვი, რომელიც მოიცავს `Service Locator`-ს, `Event Bus`-ს, `Module Registry`-ს, `Config Manager`-ს და სხვა ინფრასტრუქტურულ ნაწილებს.
- **Interfaces** — გლობალური ინტერფეისები, რომლებიც უზრუნველყოფს მოდულებს შორის "კონტრაქტებს".
- **Modules** — კატეგორიებად დაყოფილი ფუნქციონალური გაფართოებები (სენსორები, აქტუატორები, კომუნიკაციები და ა.შ.).
- **Configuration** — **(განახლებულია)** მოქნილი და **დეცენტრალიზებული** კონფიგურაციის სისტემა, რომელიც ეფუძნება `Kconfig`-ს, ბაზისურ `system_config.json`-ს და თითოეული მოდულის საკუთარ `config.json` ფაილს.

## არქიტექტურული დიაგრამა (მოკლე)

```
┌──────────────┐      Service Locator     ┌──────────────┐
│   Module A   │ ───────────────────────► │   Module B   │
└──────────────┘      (Direct Call)       └──────────────┘
        │
        │ Event Bus
        │ (Broadcast)
        ▼
┌──────────────┐
│   Module C   │
└──────────────┘
```

## სტანდარტებზე დაყრდნობით

ყველა დეტალი, naming, structure, communication და სხვა წესები აღწერილია შესაბამის convention დოკუმენტებში:

- variable_naming.md
- function_naming.md
- module_structure.md
- configuration_management.md
- communication_patterns.md
- error_handling.md
- logging_standards.md
- coding_doxygen_standard.md

---

შემდეგი ნაბიჯი: დეტალურად განვიხილოთ საქაღალდის სტრუქტურა და მოდულების არქიტექტურა.
